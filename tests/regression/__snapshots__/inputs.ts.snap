// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`inputs should properly generate input type class for filtering by enums values: ColorFilter 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { Color } from \\"../../enums/Color\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class ColorFilter {
  @Field(_type => Color, {
    nullable: true,
    description: undefined
  })
  equals?: keyof typeof Color | null;

  @Field(_type => Color, {
    nullable: true,
    description: undefined
  })
  not?: keyof typeof Color | null;

  @Field(_type => [Color], {
    nullable: true,
    description: undefined
  })
  in?: Array<keyof typeof Color> | null;

  @Field(_type => [Color], {
    nullable: true,
    description: undefined
  })
  notIn?: Array<keyof typeof Color> | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by fields: SampleModelWhereInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { BooleanFilter } from \\"../inputs/BooleanFilter\\";
import { DateTimeFilter } from \\"../inputs/DateTimeFilter\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class SampleModelWhereInput {
  @Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  intIdField?: IntFilter | null;

  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  stringField?: StringFilter | null;

  @Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  floatField?: FloatFilter | null;

  @Field(_type => BooleanFilter, {
    nullable: true,
    description: undefined
  })
  booleanField?: BooleanFilter | null;

  @Field(_type => DateTimeFilter, {
    nullable: true,
    description: undefined
  })
  dateField?: DateTimeFilter | null;

  @Field(_type => [SampleModelWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: SampleModelWhereInput[] | null;

  @Field(_type => [SampleModelWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: SampleModelWhereInput[] | null;

  @Field(_type => [SampleModelWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: SampleModelWhereInput[] | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by fields: SampleModelWhereUniqueInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class SampleModelWhereUniqueInput {
  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  intIdField?: number | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  stringField?: string | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by relation fields: FirstModelOrderByInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { OrderByArg } from \\"../../enums/OrderByArg\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstModelOrderByInput {
  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  idField?: keyof typeof OrderByArg | null;

  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  uniqueStringField?: keyof typeof OrderByArg | null;

  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  floatField?: keyof typeof OrderByArg | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by relation fields: FirstModelScalarWhereInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { SecondModelFilter } from \\"../inputs/SecondModelFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstModelScalarWhereInput {
  @Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  idField?: IntFilter | null;

  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  uniqueStringField?: StringFilter | null;

  @Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  floatField?: FloatFilter | null;

  @Field(_type => SecondModelFilter, {
    nullable: true,
    description: undefined
  })
  secondModelsField?: SecondModelFilter | null;

  @Field(_type => [FirstModelScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: FirstModelScalarWhereInput[] | null;

  @Field(_type => [FirstModelScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: FirstModelScalarWhereInput[] | null;

  @Field(_type => [FirstModelScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: FirstModelScalarWhereInput[] | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by relation fields: FirstModelWhereInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { SecondModelFilter } from \\"../inputs/SecondModelFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstModelWhereInput {
  @Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  idField?: IntFilter | null;

  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  uniqueStringField?: StringFilter | null;

  @Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  floatField?: FloatFilter | null;

  @Field(_type => SecondModelFilter, {
    nullable: true,
    description: undefined
  })
  secondModelsField?: SecondModelFilter | null;

  @Field(_type => [FirstModelWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: FirstModelWhereInput[] | null;

  @Field(_type => [FirstModelWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: FirstModelWhereInput[] | null;

  @Field(_type => [FirstModelWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: FirstModelWhereInput[] | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by relation fields: FirstModelWhereUniqueInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstModelWhereUniqueInput {
  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  idField?: number | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  uniqueStringField?: string | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: BooleanFilter 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class BooleanFilter {
  @Field(_type => Boolean, {
    nullable: true,
    description: undefined
  })
  equals?: boolean | null;

  @Field(_type => Boolean, {
    nullable: true,
    description: undefined
  })
  not?: boolean | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: DateTimeFilter 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class DateTimeFilter {
  @Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  equals?: Date | null;

  @Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  not?: Date | null;

  @Field(_type => [Date], {
    nullable: true,
    description: undefined
  })
  in?: Date[] | null;

  @Field(_type => [Date], {
    nullable: true,
    description: undefined
  })
  notIn?: Date[] | null;

  @Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  lt?: Date | null;

  @Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  lte?: Date | null;

  @Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  gt?: Date | null;

  @Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  gte?: Date | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: FloatFilter 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FloatFilter {
  @Field(_type => Float, {
    nullable: true,
    description: undefined
  })
  equals?: number | null;

  @Field(_type => Float, {
    nullable: true,
    description: undefined
  })
  not?: number | null;

  @Field(_type => [Float], {
    nullable: true,
    description: undefined
  })
  in?: number[] | null;

  @Field(_type => [Float], {
    nullable: true,
    description: undefined
  })
  notIn?: number[] | null;

  @Field(_type => Float, {
    nullable: true,
    description: undefined
  })
  lt?: number | null;

  @Field(_type => Float, {
    nullable: true,
    description: undefined
  })
  lte?: number | null;

  @Field(_type => Float, {
    nullable: true,
    description: undefined
  })
  gt?: number | null;

  @Field(_type => Float, {
    nullable: true,
    description: undefined
  })
  gte?: number | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: IntFilter 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class IntFilter {
  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  equals?: number | null;

  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  not?: number | null;

  @Field(_type => [Int], {
    nullable: true,
    description: undefined
  })
  in?: number[] | null;

  @Field(_type => [Int], {
    nullable: true,
    description: undefined
  })
  notIn?: number[] | null;

  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  lt?: number | null;

  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  lte?: number | null;

  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  gt?: number | null;

  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  gte?: number | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: StringFilter 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class StringFilter {
  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  equals?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  not?: string | null;

  @Field(_type => [String], {
    nullable: true,
    description: undefined
  })
  in?: string[] | null;

  @Field(_type => [String], {
    nullable: true,
    description: undefined
  })
  notIn?: string[] | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  lt?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  lte?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  gt?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  gte?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  contains?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  startsWith?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  endsWith?: string | null;
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorOrderByInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { OrderByArg } from \\"../../enums/OrderByArg\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class DirectorOrderByInput {
  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  firstName?: keyof typeof OrderByArg | null;

  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  lastName?: keyof typeof OrderByArg | null;

  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  age?: keyof typeof OrderByArg | null;
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorWhereInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { MovieFilter } from \\"../inputs/MovieFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class DirectorWhereInput {
  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  firstName?: StringFilter | null;

  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  lastName?: StringFilter | null;

  @Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  age?: IntFilter | null;

  @Field(_type => MovieFilter, {
    nullable: true,
    description: undefined
  })
  movies?: MovieFilter | null;

  @Field(_type => [DirectorWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: DirectorWhereInput[] | null;

  @Field(_type => [DirectorWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: DirectorWhereInput[] | null;

  @Field(_type => [DirectorWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: DirectorWhereInput[] | null;
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: DirectorWhereUniqueInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { FirstNameLastNameCompoundUniqueInput } from \\"../inputs/FirstNameLastNameCompoundUniqueInput\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class DirectorWhereUniqueInput {
  @Field(_type => FirstNameLastNameCompoundUniqueInput, {
    nullable: true,
    description: undefined
  })
  firstName_lastName?: FirstNameLastNameCompoundUniqueInput | null;
}
"
`;

exports[`inputs should properly generate input type classes for model with composite unique index: FirstNameLastNameCompoundUniqueInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstNameLastNameCompoundUniqueInput {
  @Field(_type => String, {
    nullable: false,
    description: undefined
  })
  firstName!: string;

  @Field(_type => String, {
    nullable: false,
    description: undefined
  })
  lastName!: string;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput {
  @Field(_type => String, {
    nullable: false,
    description: undefined
  })
  directorFirstName!: string;

  @Field(_type => String, {
    nullable: false,
    description: undefined
  })
  directorLastName!: string;

  @Field(_type => String, {
    nullable: false,
    description: undefined
  })
  title!: string;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieOrderByInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { OrderByArg } from \\"../../enums/OrderByArg\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class MovieOrderByInput {
  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  directorFirstName?: keyof typeof OrderByArg | null;

  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  directorLastName?: keyof typeof OrderByArg | null;

  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  title?: keyof typeof OrderByArg | null;

  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  rating?: keyof typeof OrderByArg | null;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieScalarWhereInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class MovieScalarWhereInput {
  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  directorFirstName?: StringFilter | null;

  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  directorLastName?: StringFilter | null;

  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  title?: StringFilter | null;

  @Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  rating?: FloatFilter | null;

  @Field(_type => [MovieScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: MovieScalarWhereInput[] | null;

  @Field(_type => [MovieScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: MovieScalarWhereInput[] | null;

  @Field(_type => [MovieScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: MovieScalarWhereInput[] | null;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieWhereInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { DirectorWhereInput } from \\"../inputs/DirectorWhereInput\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class MovieWhereInput {
  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  directorFirstName?: StringFilter | null;

  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  directorLastName?: StringFilter | null;

  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  title?: StringFilter | null;

  @Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  rating?: FloatFilter | null;

  @Field(_type => [MovieWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: MovieWhereInput[] | null;

  @Field(_type => [MovieWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: MovieWhereInput[] | null;

  @Field(_type => [MovieWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: MovieWhereInput[] | null;

  @Field(_type => DirectorWhereInput, {
    nullable: true,
    description: undefined
  })
  director?: DirectorWhereInput | null;
}
"
`;

exports[`inputs should properly generate input type classes for model with id keys with relation: MovieWhereUniqueInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput } from \\"../inputs/DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class MovieWhereUniqueInput {
  @Field(_type => DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput, {
    nullable: true,
    description: undefined
  })
  directorFirstName_directorLastName_title?: DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput | null;
}
"
`;
