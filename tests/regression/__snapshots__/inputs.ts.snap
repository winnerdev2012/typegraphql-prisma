// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`inputs should properly generate input type class for filtering by enums values: ColorFilter 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { Color } from \\"../../enums/Color\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class ColorFilter {
  @Field(_type => Color, {
    nullable: true,
    description: undefined
  })
  equals?: keyof typeof Color | null;

  @Field(_type => Color, {
    nullable: true,
    description: undefined
  })
  not?: keyof typeof Color | null;

  @Field(_type => [Color], {
    nullable: true,
    description: undefined
  })
  in?: keyof typeof Color[] | null;

  @Field(_type => [Color], {
    nullable: true,
    description: undefined
  })
  notIn?: keyof typeof Color[] | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by fields: SampleModelWhereInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { BooleanFilter } from \\"../inputs/BooleanFilter\\";
import { DateTimeFilter } from \\"../inputs/DateTimeFilter\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class SampleModelWhereInput {
  @Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  intIdField?: IntFilter | null;

  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  stringField?: StringFilter | null;

  @Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  floatField?: FloatFilter | null;

  @Field(_type => BooleanFilter, {
    nullable: true,
    description: undefined
  })
  booleanField?: BooleanFilter | null;

  @Field(_type => DateTimeFilter, {
    nullable: true,
    description: undefined
  })
  dateField?: DateTimeFilter | null;

  @Field(_type => [SampleModelWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: SampleModelWhereInput[] | null;

  @Field(_type => [SampleModelWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: SampleModelWhereInput[] | null;

  @Field(_type => [SampleModelWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: SampleModelWhereInput[] | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by fields: SampleModelWhereUniqueInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class SampleModelWhereUniqueInput {
  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  intIdField?: number | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  stringField?: string | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by relation fields: FirstModelOrderByInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { OrderByArg } from \\"../../enums/OrderByArg\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstModelOrderByInput {
  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  idField?: keyof typeof OrderByArg | null;

  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  uniqueStringField?: keyof typeof OrderByArg | null;

  @Field(_type => OrderByArg, {
    nullable: true,
    description: undefined
  })
  floatField?: keyof typeof OrderByArg | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by relation fields: FirstModelScalarWhereInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { SecondModelFilter } from \\"../inputs/SecondModelFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstModelScalarWhereInput {
  @Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  idField?: IntFilter | null;

  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  uniqueStringField?: StringFilter | null;

  @Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  floatField?: FloatFilter | null;

  @Field(_type => SecondModelFilter, {
    nullable: true,
    description: undefined
  })
  secondModelsField?: SecondModelFilter | null;

  @Field(_type => [FirstModelScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: FirstModelScalarWhereInput[] | null;

  @Field(_type => [FirstModelScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: FirstModelScalarWhereInput[] | null;

  @Field(_type => [FirstModelScalarWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: FirstModelScalarWhereInput[] | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by relation fields: FirstModelWhereInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";
import { FloatFilter } from \\"../inputs/FloatFilter\\";
import { IntFilter } from \\"../inputs/IntFilter\\";
import { SecondModelFilter } from \\"../inputs/SecondModelFilter\\";
import { StringFilter } from \\"../inputs/StringFilter\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstModelWhereInput {
  @Field(_type => IntFilter, {
    nullable: true,
    description: undefined
  })
  idField?: IntFilter | null;

  @Field(_type => StringFilter, {
    nullable: true,
    description: undefined
  })
  uniqueStringField?: StringFilter | null;

  @Field(_type => FloatFilter, {
    nullable: true,
    description: undefined
  })
  floatField?: FloatFilter | null;

  @Field(_type => SecondModelFilter, {
    nullable: true,
    description: undefined
  })
  secondModelsField?: SecondModelFilter | null;

  @Field(_type => [FirstModelWhereInput], {
    nullable: true,
    description: undefined
  })
  AND?: FirstModelWhereInput[] | null;

  @Field(_type => [FirstModelWhereInput], {
    nullable: true,
    description: undefined
  })
  OR?: FirstModelWhereInput[] | null;

  @Field(_type => [FirstModelWhereInput], {
    nullable: true,
    description: undefined
  })
  NOT?: FirstModelWhereInput[] | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering models by relation fields: FirstModelWhereUniqueInput 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FirstModelWhereUniqueInput {
  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  idField?: number | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  uniqueStringField?: string | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: BooleanFilter 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class BooleanFilter {
  @Field(_type => Boolean, {
    nullable: true,
    description: undefined
  })
  equals?: boolean | null;

  @Field(_type => Boolean, {
    nullable: true,
    description: undefined
  })
  not?: boolean | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: DateTimeFilter 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class DateTimeFilter {
  @Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  equals?: Date | null;

  @Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  not?: Date | null;

  @Field(_type => [Date], {
    nullable: true,
    description: undefined
  })
  in?: Date[] | null;

  @Field(_type => [Date], {
    nullable: true,
    description: undefined
  })
  notIn?: Date[] | null;

  @Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  lt?: Date | null;

  @Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  lte?: Date | null;

  @Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  gt?: Date | null;

  @Field(_type => Date, {
    nullable: true,
    description: undefined
  })
  gte?: Date | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: FloatFilter 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class FloatFilter {
  @Field(_type => Float, {
    nullable: true,
    description: undefined
  })
  equals?: number | null;

  @Field(_type => Float, {
    nullable: true,
    description: undefined
  })
  not?: number | null;

  @Field(_type => [Float], {
    nullable: true,
    description: undefined
  })
  in?: number[] | null;

  @Field(_type => [Float], {
    nullable: true,
    description: undefined
  })
  notIn?: number[] | null;

  @Field(_type => Float, {
    nullable: true,
    description: undefined
  })
  lt?: number | null;

  @Field(_type => Float, {
    nullable: true,
    description: undefined
  })
  lte?: number | null;

  @Field(_type => Float, {
    nullable: true,
    description: undefined
  })
  gt?: number | null;

  @Field(_type => Float, {
    nullable: true,
    description: undefined
  })
  gte?: number | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: IntFilter 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class IntFilter {
  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  equals?: number | null;

  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  not?: number | null;

  @Field(_type => [Int], {
    nullable: true,
    description: undefined
  })
  in?: number[] | null;

  @Field(_type => [Int], {
    nullable: true,
    description: undefined
  })
  notIn?: number[] | null;

  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  lt?: number | null;

  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  lte?: number | null;

  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  gt?: number | null;

  @Field(_type => Int, {
    nullable: true,
    description: undefined
  })
  gte?: number | null;
}
"
`;

exports[`inputs should properly generate input type classes for filtering scalar fields: StringFilter 1`] = `
"import { Arg, Args, ArgsType, Ctx, Field, FieldResolver, Float, ID, InputType, Int, Mutation, ObjectType, Query, Resolver, Root, registerEnumType } from \\"type-graphql\\";

@InputType({
  isAbstract: true,
  description: undefined,
})
export class StringFilter {
  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  equals?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  not?: string | null;

  @Field(_type => [String], {
    nullable: true,
    description: undefined
  })
  in?: string[] | null;

  @Field(_type => [String], {
    nullable: true,
    description: undefined
  })
  notIn?: string[] | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  lt?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  lte?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  gt?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  gte?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  contains?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  startsWith?: string | null;

  @Field(_type => String, {
    nullable: true,
    description: undefined
  })
  endsWith?: string | null;
}
"
`;
