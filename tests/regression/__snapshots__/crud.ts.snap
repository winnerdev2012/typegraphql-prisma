// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`crud should properly generate actions resolver classes for prisma model: CreateOneUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { CreateUserArgs } from \\"./args/CreateUserArgs\\";
import { User } from \\"../../../models/User\\";

@TypeGraphQL.Resolver(_of => User)
export class CreateUserResolver {
  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false,
    description: undefined
  })
  async createUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: CreateUserArgs): Promise<User> {
    return ctx.prisma.user.create(args);
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: DeleteManyUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { BatchPayload } from \\"../../outputs/BatchPayload\\";

@TypeGraphQL.Resolver(_of => User)
export class DeleteManyUserResolver {
  @TypeGraphQL.Mutation(_returns => BatchPayload, {
    nullable: false,
    description: undefined
  })
  async deleteManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: DeleteManyUserArgs): Promise<BatchPayload> {
    return ctx.prisma.user.deleteMany(args);
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: DeleteUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { DeleteUserArgs } from \\"./args/DeleteUserArgs\\";
import { User } from \\"../../../models/User\\";

@TypeGraphQL.Resolver(_of => User)
export class DeleteUserResolver {
  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true,
    description: undefined
  })
  async deleteUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: DeleteUserArgs): Promise<User | null> {
    return ctx.prisma.user.delete(args);
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindFirstUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { User } from \\"../../../models/User\\";

@TypeGraphQL.Resolver(_of => User)
export class FindFirstUserResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true,
    description: undefined
  })
  async findFirstUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindFirstUserArgs): Promise<User | null> {
    return ctx.prisma.user.findFirst(args);
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindManyUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { User } from \\"../../../models/User\\";

@TypeGraphQL.Resolver(_of => User)
export class FindManyUserResolver {
  @TypeGraphQL.Query(_returns => [User], {
    nullable: false,
    description: undefined
  })
  async users(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindManyUserArgs): Promise<User[]> {
    return ctx.prisma.user.findMany(args);
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: FindUniqueUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { User } from \\"../../../models/User\\";

@TypeGraphQL.Resolver(_of => User)
export class FindUniqueUserResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true,
    description: undefined
  })
  async user(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
    return ctx.prisma.user.findUnique(args);
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: Index 1`] = `
"export * from \\"./resolvers-actions.index\\";
export * from \\"./resolvers-crud.index\\";
export * from \\"./args.index\\";
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: UpdateManyUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { User } from \\"../../../models/User\\";
import { BatchPayload } from \\"../../outputs/BatchPayload\\";

@TypeGraphQL.Resolver(_of => User)
export class UpdateManyUserResolver {
  @TypeGraphQL.Mutation(_returns => BatchPayload, {
    nullable: false,
    description: undefined
  })
  async updateManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpdateManyUserArgs): Promise<BatchPayload> {
    return ctx.prisma.user.updateMany(args);
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: UpdateUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { UpdateUserArgs } from \\"./args/UpdateUserArgs\\";
import { User } from \\"../../../models/User\\";

@TypeGraphQL.Resolver(_of => User)
export class UpdateUserResolver {
  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true,
    description: undefined
  })
  async updateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpdateUserArgs): Promise<User | null> {
    return ctx.prisma.user.update(args);
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: UpsertUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { UpsertUserArgs } from \\"./args/UpsertUserArgs\\";
import { User } from \\"../../../models/User\\";

@TypeGraphQL.Resolver(_of => User)
export class UpsertUserResolver {
  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false,
    description: undefined
  })
  async upsertUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpsertUserArgs): Promise<User> {
    return ctx.prisma.user.upsert(args);
  }
}
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: actionsIndex 1`] = `
"export { FindUniqueUserResolver } from \\"./User/FindUniqueUserResolver\\";
export { FindFirstUserResolver } from \\"./User/FindFirstUserResolver\\";
export { FindManyUserResolver } from \\"./User/FindManyUserResolver\\";
export { CreateUserResolver } from \\"./User/CreateUserResolver\\";
export { DeleteUserResolver } from \\"./User/DeleteUserResolver\\";
export { UpdateUserResolver } from \\"./User/UpdateUserResolver\\";
export { DeleteManyUserResolver } from \\"./User/DeleteManyUserResolver\\";
export { UpdateManyUserResolver } from \\"./User/UpdateManyUserResolver\\";
export { UpsertUserResolver } from \\"./User/UpsertUserResolver\\";
export { AggregateUserResolver } from \\"./User/AggregateUserResolver\\";
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: argsIndex 1`] = `
"export * from \\"./User/args\\";
"
`;

exports[`crud should properly generate actions resolver classes for prisma model: crudIndex 1`] = `
"export { UserCrudResolver } from \\"./User/UserCrudResolver\\";
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: AggregateUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { UserOrderByInput } from \\"../../../inputs/UserOrderByInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";
import { UserDistinctFieldEnum } from \\"../../../../enums/UserDistinctFieldEnum\\";

@TypeGraphQL.ArgsType()
export class AggregateUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, { nullable: true })
  where?: UserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UserOrderByInput], { nullable: true })
  orderBy?: UserOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, { nullable: true })
  cursor?: UserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, { nullable: true })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, { nullable: true })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [UserDistinctFieldEnum], { nullable: true })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: CreateUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { UserCreateInput } from \\"../../../inputs/UserCreateInput\\";

@TypeGraphQL.ArgsType()
export class CreateUserArgs {
  @TypeGraphQL.Field(_type => UserCreateInput, { nullable: false })
  data!: UserCreateInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: DeleteManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";

@TypeGraphQL.ArgsType()
export class DeleteManyUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, { nullable: true })
  where?: UserWhereInput | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: DeleteUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class DeleteUserArgs {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindFirstUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { UserOrderByInput } from \\"../../../inputs/UserOrderByInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";
import { UserDistinctFieldEnum } from \\"../../../../enums/UserDistinctFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindFirstUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, { nullable: true })
  where?: UserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UserOrderByInput], { nullable: true })
  orderBy?: UserOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, { nullable: true })
  cursor?: UserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, { nullable: true })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, { nullable: true })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [UserDistinctFieldEnum], { nullable: true })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { UserOrderByInput } from \\"../../../inputs/UserOrderByInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";
import { UserDistinctFieldEnum } from \\"../../../../enums/UserDistinctFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindManyUserArgs {
  @TypeGraphQL.Field(_type => UserWhereInput, { nullable: true })
  where?: UserWhereInput | undefined;

  @TypeGraphQL.Field(_type => [UserOrderByInput], { nullable: true })
  orderBy?: UserOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, { nullable: true })
  cursor?: UserWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, { nullable: true })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, { nullable: true })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [UserDistinctFieldEnum], { nullable: true })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: FindUniqueUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class FindUniqueUserArgs {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: Index 1`] = `
"export { AggregateUserArgs } from \\"./AggregateUserArgs\\";
export { CreateUserArgs } from \\"./CreateUserArgs\\";
export { DeleteManyUserArgs } from \\"./DeleteManyUserArgs\\";
export { DeleteUserArgs } from \\"./DeleteUserArgs\\";
export { FindFirstUserArgs } from \\"./FindFirstUserArgs\\";
export { FindManyUserArgs } from \\"./FindManyUserArgs\\";
export { FindUniqueUserArgs } from \\"./FindUniqueUserArgs\\";
export { UpdateManyUserArgs } from \\"./UpdateManyUserArgs\\";
export { UpdateUserArgs } from \\"./UpdateUserArgs\\";
export { UpsertUserArgs } from \\"./UpsertUserArgs\\";
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: UpdateManyUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { UserUpdateManyMutationInput } from \\"../../../inputs/UserUpdateManyMutationInput\\";
import { UserWhereInput } from \\"../../../inputs/UserWhereInput\\";

@TypeGraphQL.ArgsType()
export class UpdateManyUserArgs {
  @TypeGraphQL.Field(_type => UserUpdateManyMutationInput, { nullable: false })
  data!: UserUpdateManyMutationInput;

  @TypeGraphQL.Field(_type => UserWhereInput, { nullable: true })
  where?: UserWhereInput | undefined;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: UpdateUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { UserUpdateInput } from \\"../../../inputs/UserUpdateInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpdateUserArgs {
  @TypeGraphQL.Field(_type => UserUpdateInput, { nullable: false })
  data!: UserUpdateInput;

  @TypeGraphQL.Field(_type => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;
}
"
`;

exports[`crud should properly generate args classes for every method of crud resolver: UpsertUserArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { UserCreateInput } from \\"../../../inputs/UserCreateInput\\";
import { UserUpdateInput } from \\"../../../inputs/UserUpdateInput\\";
import { UserWhereUniqueInput } from \\"../../../inputs/UserWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpsertUserArgs {
  @TypeGraphQL.Field(_type => UserWhereUniqueInput, { nullable: false })
  where!: UserWhereUniqueInput;

  @TypeGraphQL.Field(_type => UserCreateInput, { nullable: false })
  create!: UserCreateInput;

  @TypeGraphQL.Field(_type => UserUpdateInput, { nullable: false })
  update!: UserUpdateInput;
}
"
`;

exports[`crud should properly generate resolver class for single prisma model: Index 1`] = `
"export * from \\"./resolvers-actions.index\\";
export * from \\"./resolvers-crud.index\\";
export * from \\"./args.index\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: UserCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateUserArgs } from \\"./args/CreateUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteUserArgs } from \\"./args/DeleteUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateUserArgs } from \\"./args/UpdateUserArgs\\";
import { UpsertUserArgs } from \\"./args/UpsertUserArgs\\";
import { User } from \\"../../../models/User\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { BatchPayload } from \\"../../outputs/BatchPayload\\";

@TypeGraphQL.Resolver(_of => User)
export class UserCrudResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true,
    description: undefined
  })
  async user(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
    return ctx.prisma.user.findUnique(args);
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true,
    description: undefined
  })
  async findFirstUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindFirstUserArgs): Promise<User | null> {
    return ctx.prisma.user.findFirst(args);
  }

  @TypeGraphQL.Query(_returns => [User], {
    nullable: false,
    description: undefined
  })
  async users(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindManyUserArgs): Promise<User[]> {
    return ctx.prisma.user.findMany(args);
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false,
    description: undefined
  })
  async createUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: CreateUserArgs): Promise<User> {
    return ctx.prisma.user.create(args);
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true,
    description: undefined
  })
  async deleteUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: DeleteUserArgs): Promise<User | null> {
    return ctx.prisma.user.delete(args);
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true,
    description: undefined
  })
  async updateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpdateUserArgs): Promise<User | null> {
    return ctx.prisma.user.update(args);
  }

  @TypeGraphQL.Mutation(_returns => BatchPayload, {
    nullable: false,
    description: undefined
  })
  async deleteManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: DeleteManyUserArgs): Promise<BatchPayload> {
    return ctx.prisma.user.deleteMany(args);
  }

  @TypeGraphQL.Mutation(_returns => BatchPayload, {
    nullable: false,
    description: undefined
  })
  async updateManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpdateManyUserArgs): Promise<BatchPayload> {
    return ctx.prisma.user.updateMany(args);
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false,
    description: undefined
  })
  async upsertUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpsertUserArgs): Promise<User> {
    return ctx.prisma.user.upsert(args);
  }

  @TypeGraphQL.Query(_returns => AggregateUser, {
    nullable: false,
    description: undefined
  })
  async aggregateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateUserArgs): Promise<AggregateUser> {
    function transformFields(fields: Record<string, any>): Record<string, any> {
      return Object.fromEntries(
        Object.entries(fields)
          .filter(([key, value]) => !key.startsWith(\\"_\\"))
          .map<[string, any]>(([key, value]) => {
            if (Object.keys(value).length === 0) {
              return [key, true];
            }
            return [key, transformFields(value)];
          }),
      );
    }

    return ctx.prisma.user.aggregate({
      ...args,
      ...transformFields(graphqlFields(info as any)),
    });
  }
}
"
`;

exports[`crud should properly generate resolver class for single prisma model: actionsIndex 1`] = `
"export { FindUniqueUserResolver } from \\"./User/FindUniqueUserResolver\\";
export { FindFirstUserResolver } from \\"./User/FindFirstUserResolver\\";
export { FindManyUserResolver } from \\"./User/FindManyUserResolver\\";
export { CreateUserResolver } from \\"./User/CreateUserResolver\\";
export { DeleteUserResolver } from \\"./User/DeleteUserResolver\\";
export { UpdateUserResolver } from \\"./User/UpdateUserResolver\\";
export { DeleteManyUserResolver } from \\"./User/DeleteManyUserResolver\\";
export { UpdateManyUserResolver } from \\"./User/UpdateManyUserResolver\\";
export { UpsertUserResolver } from \\"./User/UpsertUserResolver\\";
export { AggregateUserResolver } from \\"./User/AggregateUserResolver\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: argsIndex 1`] = `
"export * from \\"./User/args\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: crudIndex 1`] = `
"export { UserCrudResolver } from \\"./User/UserCrudResolver\\";
"
`;

exports[`crud should properly generate resolver class for single prisma model: mainIndex 1`] = `
"import { NonEmptyArray } from \\"type-graphql\\";
import * as crudResolversImport from \\"./resolvers/crud/resolvers-crud.index\\";

export * from \\"./enums\\";
export * from \\"./models\\";
export * from \\"./resolvers/crud\\";
export * from \\"./resolvers/inputs\\";
export * from \\"./resolvers/outputs\\";
export * from \\"./enhance\\";

export const crudResolvers = Object.values(crudResolversImport) as unknown as NonEmptyArray<Function>;
export const resolvers = [...crudResolvers] as unknown as NonEmptyArray<Function>;
"
`;

exports[`crud should properly generate resolver class when cannot pluralize model name: StaffCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateStaffArgs } from \\"./args/AggregateStaffArgs\\";
import { CreateStaffArgs } from \\"./args/CreateStaffArgs\\";
import { DeleteManyStaffArgs } from \\"./args/DeleteManyStaffArgs\\";
import { DeleteStaffArgs } from \\"./args/DeleteStaffArgs\\";
import { FindFirstStaffArgs } from \\"./args/FindFirstStaffArgs\\";
import { FindManyStaffArgs } from \\"./args/FindManyStaffArgs\\";
import { FindUniqueStaffArgs } from \\"./args/FindUniqueStaffArgs\\";
import { UpdateManyStaffArgs } from \\"./args/UpdateManyStaffArgs\\";
import { UpdateStaffArgs } from \\"./args/UpdateStaffArgs\\";
import { UpsertStaffArgs } from \\"./args/UpsertStaffArgs\\";
import { Staff } from \\"../../../models/Staff\\";
import { AggregateStaff } from \\"../../outputs/AggregateStaff\\";
import { BatchPayload } from \\"../../outputs/BatchPayload\\";

@TypeGraphQL.Resolver(_of => Staff)
export class StaffCrudResolver {
  @TypeGraphQL.Query(_returns => Staff, {
    nullable: true,
    description: undefined
  })
  async findUniqueStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindUniqueStaffArgs): Promise<Staff | null> {
    return ctx.prisma.staff.findUnique(args);
  }

  @TypeGraphQL.Query(_returns => Staff, {
    nullable: true,
    description: undefined
  })
  async findFirstStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindFirstStaffArgs): Promise<Staff | null> {
    return ctx.prisma.staff.findFirst(args);
  }

  @TypeGraphQL.Query(_returns => [Staff], {
    nullable: false,
    description: undefined
  })
  async findManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindManyStaffArgs): Promise<Staff[]> {
    return ctx.prisma.staff.findMany(args);
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: false,
    description: undefined
  })
  async createStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: CreateStaffArgs): Promise<Staff> {
    return ctx.prisma.staff.create(args);
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: true,
    description: undefined
  })
  async deleteStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: DeleteStaffArgs): Promise<Staff | null> {
    return ctx.prisma.staff.delete(args);
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: true,
    description: undefined
  })
  async updateStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpdateStaffArgs): Promise<Staff | null> {
    return ctx.prisma.staff.update(args);
  }

  @TypeGraphQL.Mutation(_returns => BatchPayload, {
    nullable: false,
    description: undefined
  })
  async deleteManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: DeleteManyStaffArgs): Promise<BatchPayload> {
    return ctx.prisma.staff.deleteMany(args);
  }

  @TypeGraphQL.Mutation(_returns => BatchPayload, {
    nullable: false,
    description: undefined
  })
  async updateManyStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpdateManyStaffArgs): Promise<BatchPayload> {
    return ctx.prisma.staff.updateMany(args);
  }

  @TypeGraphQL.Mutation(_returns => Staff, {
    nullable: false,
    description: undefined
  })
  async upsertStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpsertStaffArgs): Promise<Staff> {
    return ctx.prisma.staff.upsert(args);
  }

  @TypeGraphQL.Query(_returns => AggregateStaff, {
    nullable: false,
    description: undefined
  })
  async aggregateStaff(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateStaffArgs): Promise<AggregateStaff> {
    function transformFields(fields: Record<string, any>): Record<string, any> {
      return Object.fromEntries(
        Object.entries(fields)
          .filter(([key, value]) => !key.startsWith(\\"_\\"))
          .map<[string, any]>(([key, value]) => {
            if (Object.keys(value).length === 0) {
              return [key, true];
            }
            return [key, transformFields(value)];
          }),
      );
    }

    return ctx.prisma.staff.aggregate({
      ...args,
      ...transformFields(graphqlFields(info as any)),
    });
  }
}
"
`;

exports[`crud should properly generate resolver class when useOriginalMapping is used: FindUniqueUserResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { User } from \\"../../../models/User\\";

@TypeGraphQL.Resolver(_of => User)
export class FindUniqueUserResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true,
    description: undefined
  })
  async findUniqueUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
    return ctx.prisma.user.findUnique(args);
  }
}
"
`;

exports[`crud should properly generate resolver class when useOriginalMapping is used: UserCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateUserArgs } from \\"./args/AggregateUserArgs\\";
import { CreateUserArgs } from \\"./args/CreateUserArgs\\";
import { DeleteManyUserArgs } from \\"./args/DeleteManyUserArgs\\";
import { DeleteUserArgs } from \\"./args/DeleteUserArgs\\";
import { FindFirstUserArgs } from \\"./args/FindFirstUserArgs\\";
import { FindManyUserArgs } from \\"./args/FindManyUserArgs\\";
import { FindUniqueUserArgs } from \\"./args/FindUniqueUserArgs\\";
import { UpdateManyUserArgs } from \\"./args/UpdateManyUserArgs\\";
import { UpdateUserArgs } from \\"./args/UpdateUserArgs\\";
import { UpsertUserArgs } from \\"./args/UpsertUserArgs\\";
import { User } from \\"../../../models/User\\";
import { AggregateUser } from \\"../../outputs/AggregateUser\\";
import { BatchPayload } from \\"../../outputs/BatchPayload\\";

@TypeGraphQL.Resolver(_of => User)
export class UserCrudResolver {
  @TypeGraphQL.Query(_returns => User, {
    nullable: true,
    description: undefined
  })
  async findUniqueUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindUniqueUserArgs): Promise<User | null> {
    return ctx.prisma.user.findUnique(args);
  }

  @TypeGraphQL.Query(_returns => User, {
    nullable: true,
    description: undefined
  })
  async findFirstUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindFirstUserArgs): Promise<User | null> {
    return ctx.prisma.user.findFirst(args);
  }

  @TypeGraphQL.Query(_returns => [User], {
    nullable: false,
    description: undefined
  })
  async findManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindManyUserArgs): Promise<User[]> {
    return ctx.prisma.user.findMany(args);
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false,
    description: undefined
  })
  async createUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: CreateUserArgs): Promise<User> {
    return ctx.prisma.user.create(args);
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true,
    description: undefined
  })
  async deleteUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: DeleteUserArgs): Promise<User | null> {
    return ctx.prisma.user.delete(args);
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: true,
    description: undefined
  })
  async updateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpdateUserArgs): Promise<User | null> {
    return ctx.prisma.user.update(args);
  }

  @TypeGraphQL.Mutation(_returns => BatchPayload, {
    nullable: false,
    description: undefined
  })
  async deleteManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: DeleteManyUserArgs): Promise<BatchPayload> {
    return ctx.prisma.user.deleteMany(args);
  }

  @TypeGraphQL.Mutation(_returns => BatchPayload, {
    nullable: false,
    description: undefined
  })
  async updateManyUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpdateManyUserArgs): Promise<BatchPayload> {
    return ctx.prisma.user.updateMany(args);
  }

  @TypeGraphQL.Mutation(_returns => User, {
    nullable: false,
    description: undefined
  })
  async upsertUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpsertUserArgs): Promise<User> {
    return ctx.prisma.user.upsert(args);
  }

  @TypeGraphQL.Query(_returns => AggregateUser, {
    nullable: false,
    description: undefined
  })
  async aggregateUser(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateUserArgs): Promise<AggregateUser> {
    function transformFields(fields: Record<string, any>): Record<string, any> {
      return Object.fromEntries(
        Object.entries(fields)
          .filter(([key, value]) => !key.startsWith(\\"_\\"))
          .map<[string, any]>(([key, value]) => {
            if (Object.keys(value).length === 0) {
              return [key, true];
            }
            return [key, transformFields(value)];
          }),
      );
    }

    return ctx.prisma.user.aggregate({
      ...args,
      ...transformFields(graphqlFields(info as any)),
    });
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: CreateOneClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { CreateClientArgs } from \\"./args/CreateClientArgs\\";
import { Client } from \\"../../../models/Client\\";

@TypeGraphQL.Resolver(_of => Client)
export class CreateClientResolver {
  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: false,
    description: undefined
  })
  async createClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: CreateClientArgs): Promise<Client> {
    return ctx.prisma.user.create(args);
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: DeleteClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { DeleteClientArgs } from \\"./args/DeleteClientArgs\\";
import { Client } from \\"../../../models/Client\\";

@TypeGraphQL.Resolver(_of => Client)
export class DeleteClientResolver {
  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: true,
    description: undefined
  })
  async deleteClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: DeleteClientArgs): Promise<Client | null> {
    return ctx.prisma.user.delete(args);
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: DeleteManyClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { DeleteManyClientArgs } from \\"./args/DeleteManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { BatchPayload } from \\"../../outputs/BatchPayload\\";

@TypeGraphQL.Resolver(_of => Client)
export class DeleteManyClientResolver {
  @TypeGraphQL.Mutation(_returns => BatchPayload, {
    nullable: false,
    description: undefined
  })
  async deleteManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: DeleteManyClientArgs): Promise<BatchPayload> {
    return ctx.prisma.user.deleteMany(args);
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: FindFirstClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { FindFirstClientArgs } from \\"./args/FindFirstClientArgs\\";
import { Client } from \\"../../../models/Client\\";

@TypeGraphQL.Resolver(_of => Client)
export class FindFirstClientResolver {
  @TypeGraphQL.Query(_returns => Client, {
    nullable: true,
    description: undefined
  })
  async findFirstClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindFirstClientArgs): Promise<Client | null> {
    return ctx.prisma.user.findFirst(args);
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: FindManyClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { FindManyClientArgs } from \\"./args/FindManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";

@TypeGraphQL.Resolver(_of => Client)
export class FindManyClientResolver {
  @TypeGraphQL.Query(_returns => [Client], {
    nullable: false,
    description: undefined
  })
  async clients(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindManyClientArgs): Promise<Client[]> {
    return ctx.prisma.user.findMany(args);
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: FindUniqueClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { FindUniqueClientArgs } from \\"./args/FindUniqueClientArgs\\";
import { Client } from \\"../../../models/Client\\";

@TypeGraphQL.Resolver(_of => Client)
export class FindUniqueClientResolver {
  @TypeGraphQL.Query(_returns => Client, {
    nullable: true,
    description: undefined
  })
  async client(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindUniqueClientArgs): Promise<Client | null> {
    return ctx.prisma.user.findUnique(args);
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: UpdateClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { UpdateClientArgs } from \\"./args/UpdateClientArgs\\";
import { Client } from \\"../../../models/Client\\";

@TypeGraphQL.Resolver(_of => Client)
export class UpdateClientResolver {
  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: true,
    description: undefined
  })
  async updateClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpdateClientArgs): Promise<Client | null> {
    return ctx.prisma.user.update(args);
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: UpdateManyClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { UpdateManyClientArgs } from \\"./args/UpdateManyClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { BatchPayload } from \\"../../outputs/BatchPayload\\";

@TypeGraphQL.Resolver(_of => Client)
export class UpdateManyClientResolver {
  @TypeGraphQL.Mutation(_returns => BatchPayload, {
    nullable: false,
    description: undefined
  })
  async updateManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpdateManyClientArgs): Promise<BatchPayload> {
    return ctx.prisma.user.updateMany(args);
  }
}
"
`;

exports[`crud when model is renamed should properly generate actions resolver classes for prisma model: UpsertClientResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import { UpsertClientArgs } from \\"./args/UpsertClientArgs\\";
import { Client } from \\"../../../models/Client\\";

@TypeGraphQL.Resolver(_of => Client)
export class UpsertClientResolver {
  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: false,
    description: undefined
  })
  async upsertClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpsertClientArgs): Promise<Client> {
    return ctx.prisma.user.upsert(args);
  }
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: AggregateClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { ClientOrderByInput } from \\"../../../inputs/ClientOrderByInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";
import { ClientDistinctFieldEnum } from \\"../../../../enums/ClientDistinctFieldEnum\\";

@TypeGraphQL.ArgsType()
export class AggregateClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, { nullable: true })
  where?: ClientWhereInput | undefined;

  @TypeGraphQL.Field(_type => [ClientOrderByInput], { nullable: true })
  orderBy?: ClientOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, { nullable: true })
  cursor?: ClientWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, { nullable: true })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, { nullable: true })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [ClientDistinctFieldEnum], { nullable: true })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: CreateClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { ClientCreateInput } from \\"../../../inputs/ClientCreateInput\\";

@TypeGraphQL.ArgsType()
export class CreateClientArgs {
  @TypeGraphQL.Field(_type => ClientCreateInput, { nullable: false })
  data!: ClientCreateInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: DeleteClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class DeleteClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, { nullable: false })
  where!: ClientWhereUniqueInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: DeleteManyClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";

@TypeGraphQL.ArgsType()
export class DeleteManyClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, { nullable: true })
  where?: ClientWhereInput | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: FindFirstClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { ClientOrderByInput } from \\"../../../inputs/ClientOrderByInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";
import { ClientDistinctFieldEnum } from \\"../../../../enums/ClientDistinctFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindFirstClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, { nullable: true })
  where?: ClientWhereInput | undefined;

  @TypeGraphQL.Field(_type => [ClientOrderByInput], { nullable: true })
  orderBy?: ClientOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, { nullable: true })
  cursor?: ClientWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, { nullable: true })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, { nullable: true })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [ClientDistinctFieldEnum], { nullable: true })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: FindManyClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { ClientOrderByInput } from \\"../../../inputs/ClientOrderByInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";
import { ClientDistinctFieldEnum } from \\"../../../../enums/ClientDistinctFieldEnum\\";

@TypeGraphQL.ArgsType()
export class FindManyClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereInput, { nullable: true })
  where?: ClientWhereInput | undefined;

  @TypeGraphQL.Field(_type => [ClientOrderByInput], { nullable: true })
  orderBy?: ClientOrderByInput[] | undefined;

  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, { nullable: true })
  cursor?: ClientWhereUniqueInput | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, { nullable: true })
  take?: number | undefined;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, { nullable: true })
  skip?: number | undefined;

  @TypeGraphQL.Field(_type => [ClientDistinctFieldEnum], { nullable: true })
  distinct?: Array<\\"intIdField\\" | \\"uniqueStringField\\" | \\"optionalStringField\\" | \\"dateField\\"> | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: FindUniqueClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class FindUniqueClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, { nullable: false })
  where!: ClientWhereUniqueInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: Index 1`] = `
"export { AggregateClientArgs } from \\"./AggregateClientArgs\\";
export { CreateClientArgs } from \\"./CreateClientArgs\\";
export { DeleteClientArgs } from \\"./DeleteClientArgs\\";
export { DeleteManyClientArgs } from \\"./DeleteManyClientArgs\\";
export { FindFirstClientArgs } from \\"./FindFirstClientArgs\\";
export { FindManyClientArgs } from \\"./FindManyClientArgs\\";
export { FindUniqueClientArgs } from \\"./FindUniqueClientArgs\\";
export { UpdateClientArgs } from \\"./UpdateClientArgs\\";
export { UpdateManyClientArgs } from \\"./UpdateManyClientArgs\\";
export { UpsertClientArgs } from \\"./UpsertClientArgs\\";
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: UpdateClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { ClientUpdateInput } from \\"../../../inputs/ClientUpdateInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpdateClientArgs {
  @TypeGraphQL.Field(_type => ClientUpdateInput, { nullable: false })
  data!: ClientUpdateInput;

  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, { nullable: false })
  where!: ClientWhereUniqueInput;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: UpdateManyClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { ClientUpdateManyMutationInput } from \\"../../../inputs/ClientUpdateManyMutationInput\\";
import { ClientWhereInput } from \\"../../../inputs/ClientWhereInput\\";

@TypeGraphQL.ArgsType()
export class UpdateManyClientArgs {
  @TypeGraphQL.Field(_type => ClientUpdateManyMutationInput, { nullable: false })
  data!: ClientUpdateManyMutationInput;

  @TypeGraphQL.Field(_type => ClientWhereInput, { nullable: true })
  where?: ClientWhereInput | undefined;
}
"
`;

exports[`crud when model is renamed should properly generate args classes for every method of crud resolver: UpsertClientArgs 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import GraphQLJSON from \\"graphql-type-json\\";
import { ClientCreateInput } from \\"../../../inputs/ClientCreateInput\\";
import { ClientUpdateInput } from \\"../../../inputs/ClientUpdateInput\\";
import { ClientWhereUniqueInput } from \\"../../../inputs/ClientWhereUniqueInput\\";

@TypeGraphQL.ArgsType()
export class UpsertClientArgs {
  @TypeGraphQL.Field(_type => ClientWhereUniqueInput, { nullable: false })
  where!: ClientWhereUniqueInput;

  @TypeGraphQL.Field(_type => ClientCreateInput, { nullable: false })
  create!: ClientCreateInput;

  @TypeGraphQL.Field(_type => ClientUpdateInput, { nullable: false })
  update!: ClientUpdateInput;
}
"
`;

exports[`crud when model is renamed should properly generate resolver class for single prisma model: ClientCrudResolver 1`] = `
"import * as TypeGraphQL from \\"type-graphql\\";
import graphqlFields from \\"graphql-fields\\";
import { GraphQLResolveInfo } from \\"graphql\\";
import { AggregateClientArgs } from \\"./args/AggregateClientArgs\\";
import { CreateClientArgs } from \\"./args/CreateClientArgs\\";
import { DeleteClientArgs } from \\"./args/DeleteClientArgs\\";
import { DeleteManyClientArgs } from \\"./args/DeleteManyClientArgs\\";
import { FindFirstClientArgs } from \\"./args/FindFirstClientArgs\\";
import { FindManyClientArgs } from \\"./args/FindManyClientArgs\\";
import { FindUniqueClientArgs } from \\"./args/FindUniqueClientArgs\\";
import { UpdateClientArgs } from \\"./args/UpdateClientArgs\\";
import { UpdateManyClientArgs } from \\"./args/UpdateManyClientArgs\\";
import { UpsertClientArgs } from \\"./args/UpsertClientArgs\\";
import { Client } from \\"../../../models/Client\\";
import { AggregateClient } from \\"../../outputs/AggregateClient\\";
import { BatchPayload } from \\"../../outputs/BatchPayload\\";

@TypeGraphQL.Resolver(_of => Client)
export class ClientCrudResolver {
  @TypeGraphQL.Query(_returns => Client, {
    nullable: true,
    description: undefined
  })
  async findUniqueClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindUniqueClientArgs): Promise<Client | null> {
    return ctx.prisma.user.findUnique(args);
  }

  @TypeGraphQL.Query(_returns => Client, {
    nullable: true,
    description: undefined
  })
  async findFirstClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindFirstClientArgs): Promise<Client | null> {
    return ctx.prisma.user.findFirst(args);
  }

  @TypeGraphQL.Query(_returns => [Client], {
    nullable: false,
    description: undefined
  })
  async findManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: FindManyClientArgs): Promise<Client[]> {
    return ctx.prisma.user.findMany(args);
  }

  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: false,
    description: undefined
  })
  async createClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: CreateClientArgs): Promise<Client> {
    return ctx.prisma.user.create(args);
  }

  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: true,
    description: undefined
  })
  async deleteClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: DeleteClientArgs): Promise<Client | null> {
    return ctx.prisma.user.delete(args);
  }

  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: true,
    description: undefined
  })
  async updateClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpdateClientArgs): Promise<Client | null> {
    return ctx.prisma.user.update(args);
  }

  @TypeGraphQL.Mutation(_returns => BatchPayload, {
    nullable: false,
    description: undefined
  })
  async deleteManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: DeleteManyClientArgs): Promise<BatchPayload> {
    return ctx.prisma.user.deleteMany(args);
  }

  @TypeGraphQL.Mutation(_returns => BatchPayload, {
    nullable: false,
    description: undefined
  })
  async updateManyClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpdateManyClientArgs): Promise<BatchPayload> {
    return ctx.prisma.user.updateMany(args);
  }

  @TypeGraphQL.Mutation(_returns => Client, {
    nullable: false,
    description: undefined
  })
  async upsertClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Args() args: UpsertClientArgs): Promise<Client> {
    return ctx.prisma.user.upsert(args);
  }

  @TypeGraphQL.Query(_returns => AggregateClient, {
    nullable: false,
    description: undefined
  })
  async aggregateClient(@TypeGraphQL.Ctx() ctx: any, @TypeGraphQL.Info() info: GraphQLResolveInfo, @TypeGraphQL.Args() args: AggregateClientArgs): Promise<AggregateClient> {
    function transformFields(fields: Record<string, any>): Record<string, any> {
      return Object.fromEntries(
        Object.entries(fields)
          .filter(([key, value]) => !key.startsWith(\\"_\\"))
          .map<[string, any]>(([key, value]) => {
            if (Object.keys(value).length === 0) {
              return [key, true];
            }
            return [key, transformFields(value)];
          }),
      );
    }

    return ctx.prisma.user.aggregate({
      ...args,
      ...transformFields(graphqlFields(info as any)),
    });
  }
}
"
`;
