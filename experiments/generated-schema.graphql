# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AggregateClient {
  avg: ClientAvgAggregate
  count: ClientCountAggregate
  max: ClientMaxAggregate
  min: ClientMinAggregate
  sum: ClientSumAggregate
}

type AggregateCreator {
  avg: CreatorAvgAggregate
  count: CreatorCountAggregate
  max: CreatorMaxAggregate
  min: CreatorMinAggregate
  sum: CreatorSumAggregate
}

type AggregateDirector {
  count: DirectorCountAggregate
  max: DirectorMaxAggregate
  min: DirectorMinAggregate
}

type AggregateMovie {
  count: MovieCountAggregate
  max: MovieMaxAggregate
  min: MovieMinAggregate
}

type AggregatePatient {
  count: PatientCountAggregate
  max: PatientMaxAggregate
  min: PatientMinAggregate
}

type AggregateProblem {
  avg: ProblemAvgAggregate
  count: ProblemCountAggregate
  max: ProblemMaxAggregate
  min: ProblemMinAggregate
  sum: ProblemSumAggregate
}

type BatchPayload {
  count: Int!
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Category {
  name: String!
  number: Int!
  slug: String!
}

input CategoryOrderByInput {
  name: SortOrder
  number: SortOrder
  slug: SortOrder
}

enum CategoryScalarFieldEnum {
  name
  number
  slug
}

input CategorySlugNumberCompoundUniqueInput {
  number: Int!
  slug: String!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  name: StringFilter
  NOT: [CategoryWhereInput!]
  number: IntFilter
  OR: [CategoryWhereInput!]
  slug: StringFilter
}

input CategoryWhereUniqueInput {
  slug_number: CategorySlugNumberCompoundUniqueInput
}

"""User model doc"""
type Client {
  accountBalance: Float!
  age: Int!
  amount: Float!
  clientPosts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]
  email: String!

  """renamed field doc"""
  firstName: String
  hello: String!

  """User model field doc"""
  id: Int!
  role: Role!
}

type ClientAvgAggregate {
  age: Float!
  amount: Float!
  balance: Float!
  id: Float!
}

type ClientCountAggregate {
  _all: Int!
  age: Int!
  amount: Int!
  balance: Int!
  email: Int
  id: Int!
  name: Int
  role: Int
}

input ClientCreateInput {
  accountBalance: Float!
  age: Int!
  amount: Float!
  clientPosts: PostCreateManyWithoutAuthorInput
  editorPosts: PostCreateManyWithoutEditorInput
  email: String!
  firstName: String
  role: Role!
}

input ClientCreateOneWithoutEditorPostsInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithouteditorPostsInput
  create: ClientCreateWithoutEditorPostsInput
}

input ClientCreateOneWithoutPostsInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutpostsInput
  create: ClientCreateWithoutPostsInput
}

input ClientCreateOrConnectWithouteditorPostsInput {
  create: ClientCreateWithoutEditorPostsInput!
  where: ClientWhereUniqueInput!
}

input ClientCreateOrConnectWithoutpostsInput {
  create: ClientCreateWithoutPostsInput!
  where: ClientWhereUniqueInput!
}

input ClientCreateWithoutEditorPostsInput {
  accountBalance: Float!
  age: Int!
  amount: Float!
  clientPosts: PostCreateManyWithoutAuthorInput
  email: String!
  firstName: String
  role: Role!
}

input ClientCreateWithoutPostsInput {
  accountBalance: Float!
  age: Int!
  amount: Float!
  editorPosts: PostCreateManyWithoutEditorInput
  email: String!
  firstName: String
  role: Role!
}

type ClientMaxAggregate {
  age: Int!
  amount: Float!
  balance: Float!
  email: String
  id: Int!
  name: String
  role: Role
}

type ClientMinAggregate {
  age: Int!
  amount: Float!
  balance: Float!
  email: String
  id: Int!
  name: String
  role: Role
}

input ClientOrderByInput {
  accountBalance: SortOrder
  age: SortOrder
  amount: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  role: SortOrder
}

input ClientRelationFilter {
  is: ClientWhereInput
  isNot: ClientWhereInput
}

enum ClientScalarFieldEnum {
  accountBalance
  age
  amount
  email
  firstName
  id
  role
}

type ClientSumAggregate {
  age: Int!
  amount: Float!
  balance: Float!
  id: Int!
}

input ClientUpdateInput {
  accountBalance: FloatFieldUpdateOperationsInput
  age: IntFieldUpdateOperationsInput
  amount: FloatFieldUpdateOperationsInput
  clientPosts: PostUpdateManyWithoutAuthorInput
  editorPosts: PostUpdateManyWithoutEditorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ClientUpdateManyMutationInput {
  accountBalance: FloatFieldUpdateOperationsInput
  age: IntFieldUpdateOperationsInput
  amount: FloatFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ClientUpdateOneRequiredWithoutPostsInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutpostsInput
  create: ClientCreateWithoutPostsInput
  update: ClientUpdateWithoutPostsInput
  upsert: ClientUpsertWithoutPostsInput
}

input ClientUpdateOneWithoutEditorPostsInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithouteditorPostsInput
  create: ClientCreateWithoutEditorPostsInput
  delete: Boolean
  disconnect: Boolean
  update: ClientUpdateWithoutEditorPostsInput
  upsert: ClientUpsertWithoutEditorPostsInput
}

input ClientUpdateWithoutEditorPostsInput {
  accountBalance: FloatFieldUpdateOperationsInput
  age: IntFieldUpdateOperationsInput
  amount: FloatFieldUpdateOperationsInput
  clientPosts: PostUpdateManyWithoutAuthorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ClientUpdateWithoutPostsInput {
  accountBalance: FloatFieldUpdateOperationsInput
  age: IntFieldUpdateOperationsInput
  amount: FloatFieldUpdateOperationsInput
  editorPosts: PostUpdateManyWithoutEditorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ClientUpsertWithoutEditorPostsInput {
  create: ClientCreateWithoutEditorPostsInput!
  update: ClientUpdateWithoutEditorPostsInput!
}

input ClientUpsertWithoutPostsInput {
  create: ClientCreateWithoutPostsInput!
  update: ClientUpdateWithoutPostsInput!
}

input ClientWhereInput {
  accountBalance: FloatFilter
  age: IntFilter
  amount: FloatFilter
  AND: [ClientWhereInput!]
  clientPosts: PostListRelationFilter
  editorPosts: PostListRelationFilter
  email: StringFilter
  firstName: StringNullableFilter
  id: IntFilter
  NOT: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  role: EnumRoleFilter
}

input ClientWhereUniqueInput {
  email: String
  id: Int
}

type Creator {
  id: Int!
  likes(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByInput!], skip: Int, take: Int, where: ProblemWhereInput): [Problem!]
  name: String!
  problems(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByInput!], skip: Int, take: Int, where: ProblemWhereInput): [Problem!]
}

type CreatorAvgAggregate {
  id: Float!
}

type CreatorCountAggregate {
  _all: Int!
  id: Int!
  name: Int
}

input CreatorCreateInput {
  likes: ProblemCreateManyWithoutLikedByInput
  name: String!
  problems: ProblemCreateManyWithoutCreatorInput
}

input CreatorCreateManyWithoutLikesInput {
  connect: [CreatorWhereUniqueInput!]
  connectOrCreate: [CreatorCreateOrConnectWithoutlikesInput!]
  create: [CreatorCreateWithoutLikesInput!]
}

input CreatorCreateOneWithoutProblemsInput {
  connect: CreatorWhereUniqueInput
  connectOrCreate: CreatorCreateOrConnectWithoutproblemsInput
  create: CreatorCreateWithoutProblemsInput
}

input CreatorCreateOrConnectWithoutlikesInput {
  create: CreatorCreateWithoutLikesInput!
  where: CreatorWhereUniqueInput!
}

input CreatorCreateOrConnectWithoutproblemsInput {
  create: CreatorCreateWithoutProblemsInput!
  where: CreatorWhereUniqueInput!
}

input CreatorCreateWithoutLikesInput {
  name: String!
  problems: ProblemCreateManyWithoutCreatorInput
}

input CreatorCreateWithoutProblemsInput {
  likes: ProblemCreateManyWithoutLikedByInput
  name: String!
}

input CreatorListRelationFilter {
  every: CreatorWhereInput
  none: CreatorWhereInput
  some: CreatorWhereInput
}

type CreatorMaxAggregate {
  id: Int!
  name: String
}

type CreatorMinAggregate {
  id: Int!
  name: String
}

input CreatorOrderByInput {
  id: SortOrder
  name: SortOrder
}

input CreatorRelationFilter {
  is: CreatorWhereInput
  isNot: CreatorWhereInput
}

enum CreatorScalarFieldEnum {
  id
  name
}

input CreatorScalarWhereInput {
  AND: [CreatorScalarWhereInput!]
  id: IntFilter
  name: StringFilter
  NOT: [CreatorScalarWhereInput!]
  OR: [CreatorScalarWhereInput!]
}

type CreatorSumAggregate {
  id: Int!
}

input CreatorUpdateInput {
  likes: ProblemUpdateManyWithoutLikedByInput
  name: StringFieldUpdateOperationsInput
  problems: ProblemUpdateManyWithoutCreatorInput
}

input CreatorUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input CreatorUpdateManyWithoutLikesInput {
  connect: [CreatorWhereUniqueInput!]
  connectOrCreate: [CreatorCreateOrConnectWithoutlikesInput!]
  create: [CreatorCreateWithoutLikesInput!]
  delete: [CreatorWhereUniqueInput!]
  deleteMany: [CreatorScalarWhereInput!]
  disconnect: [CreatorWhereUniqueInput!]
  set: [CreatorWhereUniqueInput!]
  update: [CreatorUpdateWithWhereUniqueWithoutLikesInput!]
  updateMany: [CreatorUpdateManyWithWhereWithoutLikesInput!]
  upsert: [CreatorUpsertWithWhereUniqueWithoutLikesInput!]
}

input CreatorUpdateManyWithWhereWithoutLikesInput {
  data: CreatorUpdateManyMutationInput!
  where: CreatorScalarWhereInput!
}

input CreatorUpdateOneWithoutProblemsInput {
  connect: CreatorWhereUniqueInput
  connectOrCreate: CreatorCreateOrConnectWithoutproblemsInput
  create: CreatorCreateWithoutProblemsInput
  delete: Boolean
  disconnect: Boolean
  update: CreatorUpdateWithoutProblemsInput
  upsert: CreatorUpsertWithoutProblemsInput
}

input CreatorUpdateWithoutLikesInput {
  name: StringFieldUpdateOperationsInput
  problems: ProblemUpdateManyWithoutCreatorInput
}

input CreatorUpdateWithoutProblemsInput {
  likes: ProblemUpdateManyWithoutLikedByInput
  name: StringFieldUpdateOperationsInput
}

input CreatorUpdateWithWhereUniqueWithoutLikesInput {
  data: CreatorUpdateWithoutLikesInput!
  where: CreatorWhereUniqueInput!
}

input CreatorUpsertWithoutProblemsInput {
  create: CreatorCreateWithoutProblemsInput!
  update: CreatorUpdateWithoutProblemsInput!
}

input CreatorUpsertWithWhereUniqueWithoutLikesInput {
  create: CreatorCreateWithoutLikesInput!
  update: CreatorUpdateWithoutLikesInput!
  where: CreatorWhereUniqueInput!
}

input CreatorWhereInput {
  AND: [CreatorWhereInput!]
  id: IntFilter
  likes: ProblemListRelationFilter
  name: StringFilter
  NOT: [CreatorWhereInput!]
  OR: [CreatorWhereInput!]
  problems: ProblemListRelationFilter
}

input CreatorWhereUniqueInput {
  id: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type Director {
  firstName: String!
  lastName: String!
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]
}

type DirectorCountAggregate {
  _all: Int!
  firstName: Int
  lastName: Int
}

input DirectorCreateInput {
  firstName: String!
  lastName: String!
  movies: MovieCreateManyWithoutDirectorInput
}

input DirectorCreateOneWithoutMoviesInput {
  connect: DirectorWhereUniqueInput
  connectOrCreate: DirectorCreateOrConnectWithoutmoviesInput
  create: DirectorCreateWithoutMoviesInput
}

input DirectorCreateOrConnectWithoutmoviesInput {
  create: DirectorCreateWithoutMoviesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorCreateWithoutMoviesInput {
  firstName: String!
  lastName: String!
}

input DirectorFirstNameLastNameCompoundUniqueInput {
  firstName: String!
  lastName: String!
}

type DirectorMaxAggregate {
  firstName: String
  lastName: String
}

type DirectorMinAggregate {
  firstName: String
  lastName: String
}

input DirectorOrderByInput {
  firstName: SortOrder
  lastName: SortOrder
}

input DirectorRelationFilter {
  is: DirectorWhereInput
  isNot: DirectorWhereInput
}

enum DirectorScalarFieldEnum {
  firstName
  lastName
}

input DirectorUpdateInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutDirectorInput
}

input DirectorUpdateManyMutationInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input DirectorUpdateOneRequiredWithoutMoviesInput {
  connect: DirectorWhereUniqueInput
  connectOrCreate: DirectorCreateOrConnectWithoutmoviesInput
  create: DirectorCreateWithoutMoviesInput
  update: DirectorUpdateWithoutMoviesInput
  upsert: DirectorUpsertWithoutMoviesInput
}

input DirectorUpdateWithoutMoviesInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input DirectorUpsertWithoutMoviesInput {
  create: DirectorCreateWithoutMoviesInput!
  update: DirectorUpdateWithoutMoviesInput!
}

input DirectorWhereInput {
  AND: [DirectorWhereInput!]
  firstName: StringFilter
  lastName: StringFilter
  movies: MovieListRelationFilter
  NOT: [DirectorWhereInput!]
  OR: [DirectorWhereInput!]
}

input DirectorWhereUniqueInput {
  firstName_lastName: DirectorFirstNameLastNameCompoundUniqueInput
}

input EnumPostKindNullableFilter {
  equals: PostKind
  in: [PostKind!]
  not: NestedEnumPostKindNullableFilter
  notIn: [PostKind!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  equals: JSON
  not: JSON
}

type Movie {
  director: Director!
  directorFirstName: String!
  directorLastName: String!
  title: String!
}

type MovieCountAggregate {
  _all: Int!
  directorFirstName: Int
  directorLastName: Int
  title: Int
}

input MovieCreateInput {
  director: DirectorCreateOneWithoutMoviesInput!
  title: String!
}

input MovieCreateManyWithoutDirectorInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutdirectorInput!]
  create: [MovieCreateWithoutDirectorInput!]
}

input MovieCreateOrConnectWithoutdirectorInput {
  create: MovieCreateWithoutDirectorInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateWithoutDirectorInput {
  title: String!
}

input MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput {
  directorFirstName: String!
  directorLastName: String!
  title: String!
}

input MovieListRelationFilter {
  every: MovieWhereInput
  none: MovieWhereInput
  some: MovieWhereInput
}

type MovieMaxAggregate {
  directorFirstName: String
  directorLastName: String
  title: String
}

type MovieMinAggregate {
  directorFirstName: String
  directorLastName: String
  title: String
}

input MovieOrderByInput {
  directorFirstName: SortOrder
  directorLastName: SortOrder
  title: SortOrder
}

enum MovieScalarFieldEnum {
  directorFirstName
  directorLastName
  title
}

input MovieScalarWhereInput {
  AND: [MovieScalarWhereInput!]
  directorFirstName: StringFilter
  directorLastName: StringFilter
  NOT: [MovieScalarWhereInput!]
  OR: [MovieScalarWhereInput!]
  title: StringFilter
}

input MovieUpdateInput {
  director: DirectorUpdateOneRequiredWithoutMoviesInput
  title: StringFieldUpdateOperationsInput
}

input MovieUpdateManyMutationInput {
  title: StringFieldUpdateOperationsInput
}

input MovieUpdateManyWithoutDirectorInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutdirectorInput!]
  create: [MovieCreateWithoutDirectorInput!]
  delete: [MovieWhereUniqueInput!]
  deleteMany: [MovieScalarWhereInput!]
  disconnect: [MovieWhereUniqueInput!]
  set: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutDirectorInput!]
  updateMany: [MovieUpdateManyWithWhereWithoutDirectorInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutDirectorInput!]
}

input MovieUpdateManyWithWhereWithoutDirectorInput {
  data: MovieUpdateManyMutationInput!
  where: MovieScalarWhereInput!
}

input MovieUpdateWithoutDirectorInput {
  title: StringFieldUpdateOperationsInput
}

input MovieUpdateWithWhereUniqueWithoutDirectorInput {
  data: MovieUpdateWithoutDirectorInput!
  where: MovieWhereUniqueInput!
}

input MovieUpsertWithWhereUniqueWithoutDirectorInput {
  create: MovieCreateWithoutDirectorInput!
  update: MovieUpdateWithoutDirectorInput!
  where: MovieWhereUniqueInput!
}

input MovieWhereInput {
  AND: [MovieWhereInput!]
  director: DirectorRelationFilter
  directorFirstName: StringFilter
  directorLastName: StringFilter
  NOT: [MovieWhereInput!]
  OR: [MovieWhereInput!]
  title: StringFilter
}

input MovieWhereUniqueInput {
  directorFirstName_directorLastName_title: MovieDirectorFirstNameDirectorLastNameTitleCompoundUniqueInput
}

type Mutation {
  createClient(data: ClientCreateInput!): Client!
  createCreator(data: CreatorCreateInput!): Creator!
  createDirector(data: DirectorCreateInput!): Director!
  createMovie(data: MovieCreateInput!): Movie!
  createPatient(data: PatientCreateInput!): Patient!
  createPost(data: PostCreateInput!): Post!
  createProblem(data: ProblemCreateInput!): Problem!
  customCreatePost(data: PostCreateInput!): Post!
  deleteClient(where: ClientWhereUniqueInput!): Client
  deleteCreator(where: CreatorWhereUniqueInput!): Creator
  deleteDirector(where: DirectorWhereUniqueInput!): Director
  deleteManyClient(where: ClientWhereInput): BatchPayload!
  deleteManyCreator(where: CreatorWhereInput): BatchPayload!
  deleteManyDirector(where: DirectorWhereInput): BatchPayload!
  deleteManyMovie(where: MovieWhereInput): BatchPayload!
  deleteManyPatient(where: PatientWhereInput): BatchPayload!
  deleteManyProblem(where: ProblemWhereInput): BatchPayload!
  deleteMovie(where: MovieWhereUniqueInput!): Movie
  deletePatient(where: PatientWhereUniqueInput!): Patient
  deleteProblem(where: ProblemWhereUniqueInput!): Problem
  updateClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateCreator(data: CreatorUpdateInput!, where: CreatorWhereUniqueInput!): Creator
  updateDirector(data: DirectorUpdateInput!, where: DirectorWhereUniqueInput!): Director
  updateManyClient(data: ClientUpdateManyMutationInput!, where: ClientWhereInput): BatchPayload!
  updateManyCreator(data: CreatorUpdateManyMutationInput!, where: CreatorWhereInput): BatchPayload!
  updateManyDirector(data: DirectorUpdateManyMutationInput!, where: DirectorWhereInput): BatchPayload!
  updateManyMovie(data: MovieUpdateManyMutationInput!, where: MovieWhereInput): BatchPayload!
  updateManyPatient(data: PatientUpdateManyMutationInput!, where: PatientWhereInput): BatchPayload!
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  updateManyProblem(data: ProblemUpdateManyMutationInput!, where: ProblemWhereInput): BatchPayload!
  updateMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
  updatePatient(data: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient
  updateProblem(data: ProblemUpdateInput!, where: ProblemWhereUniqueInput!): Problem
  upsertClient(create: ClientCreateInput!, update: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client!
  upsertCreator(create: CreatorCreateInput!, update: CreatorUpdateInput!, where: CreatorWhereUniqueInput!): Creator!
  upsertDirector(create: DirectorCreateInput!, update: DirectorUpdateInput!, where: DirectorWhereUniqueInput!): Director!
  upsertMovie(create: MovieCreateInput!, update: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie!
  upsertPatient(create: PatientCreateInput!, update: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient!
  upsertProblem(create: ProblemCreateInput!, update: ProblemUpdateInput!, where: ProblemWhereUniqueInput!): Problem!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumPostKindNullableFilter {
  equals: PostKind
  in: [PostKind!]
  not: NestedEnumPostKindNullableFilter
  notIn: [PostKind!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableEnumPostKindFieldUpdateOperationsInput {
  set: PostKind
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Patient {
  email: String!
  firstName: String!
  lastName: String!
}

type PatientCountAggregate {
  _all: Int!
  email: Int
  firstName: Int
  lastName: Int
}

input PatientCreateInput {
  email: String!
  firstName: String!
  lastName: String!
}

input PatientFirstNameLastNameCompoundUniqueInput {
  firstName: String!
  lastName: String!
}

type PatientMaxAggregate {
  email: String
  firstName: String
  lastName: String
}

type PatientMinAggregate {
  email: String
  firstName: String
  lastName: String
}

input PatientOrderByInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
}

enum PatientScalarFieldEnum {
  email
  firstName
  lastName
}

input PatientUpdateInput {
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input PatientUpdateManyMutationInput {
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input PatientWhereInput {
  AND: [PatientWhereInput!]
  email: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  NOT: [PatientWhereInput!]
  OR: [PatientWhereInput!]
}

input PatientWhereUniqueInput {
  firstName_lastName: PatientFirstNameLastNameCompoundUniqueInput
}

type Post {
  author: Client!
  authorId: Int!
  content: String
  createdAt: DateTime!
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  title: String!
  updatedAt: DateTime!
  uuid: String!
}

input PostCreateInput {
  author: ClientCreateOneWithoutPostsInput!
  content: String
  createdAt: DateTime
  editor: ClientCreateOneWithoutEditorPostsInput
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime
  uuid: String
}

input PostCreateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutauthorInput!]
  create: [PostCreateWithoutAuthorInput!]
}

input PostCreateManyWithoutEditorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithouteditorInput!]
  create: [PostCreateWithoutEditorInput!]
}

input PostCreateOrConnectWithoutauthorInput {
  create: PostCreateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithouteditorInput {
  create: PostCreateWithoutEditorInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutAuthorInput {
  content: String
  createdAt: DateTime
  editor: ClientCreateOneWithoutEditorPostsInput
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime
  uuid: String
}

input PostCreateWithoutEditorInput {
  author: ClientCreateOneWithoutPostsInput!
  content: String
  createdAt: DateTime
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime
  uuid: String
}

enum PostKind {
  ADVERT
  BLOG
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

input PostOrderByInput {
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  editorId: SortOrder
  kind: SortOrder
  metadata: SortOrder
  published: SortOrder
  subtitle: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uuid: SortOrder
}

enum PostScalarFieldEnum {
  authorId
  content
  createdAt
  editorId
  kind
  metadata
  published
  subtitle
  title
  updatedAt
  uuid
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  authorId: IntFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  editorId: IntNullableFilter
  kind: EnumPostKindNullableFilter
  metadata: JsonFilter
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  published: BoolFilter
  subtitle: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  uuid: StringFilter
}

input PostUpdateManyMutationInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  kind: NullableEnumPostKindFieldUpdateOperationsInput
  metadata: JSON
  published: BoolFieldUpdateOperationsInput
  subtitle: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  uuid: StringFieldUpdateOperationsInput
}

input PostUpdateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutauthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateManyWithoutEditorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithouteditorInput!]
  create: [PostCreateWithoutEditorInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutEditorInput!]
  updateMany: [PostUpdateManyWithWhereWithoutEditorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutEditorInput!]
}

input PostUpdateManyWithWhereWithoutAuthorInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithWhereWithoutEditorInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateWithoutAuthorInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  editor: ClientUpdateOneWithoutEditorPostsInput
  kind: NullableEnumPostKindFieldUpdateOperationsInput
  metadata: JSON
  published: BoolFieldUpdateOperationsInput
  subtitle: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  uuid: StringFieldUpdateOperationsInput
}

input PostUpdateWithoutEditorInput {
  author: ClientUpdateOneRequiredWithoutPostsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  kind: NullableEnumPostKindFieldUpdateOperationsInput
  metadata: JSON
  published: BoolFieldUpdateOperationsInput
  subtitle: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  uuid: StringFieldUpdateOperationsInput
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  data: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithWhereUniqueWithoutEditorInput {
  data: PostUpdateWithoutEditorInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  update: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithWhereUniqueWithoutEditorInput {
  create: PostCreateWithoutEditorInput!
  update: PostUpdateWithoutEditorInput!
  where: PostWhereUniqueInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  author: ClientRelationFilter
  authorId: IntFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  editor: ClientRelationFilter
  editorId: IntNullableFilter
  kind: EnumPostKindNullableFilter
  metadata: JsonFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  published: BoolFilter
  subtitle: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  uuid: StringFilter
}

input PostWhereUniqueInput {
  uuid: String
}

type Problem {
  creator: Creator
  creatorId: Int
  id: Int!
  likedBy(cursor: CreatorWhereUniqueInput, distinct: [CreatorScalarFieldEnum!], orderBy: [CreatorOrderByInput!], skip: Int, take: Int, where: CreatorWhereInput): [Creator!]
  problemText: String!
}

type ProblemAvgAggregate {
  creatorId: Float
  id: Float!
}

type ProblemCountAggregate {
  _all: Int!
  creatorId: Int
  id: Int!
  problemText: Int
}

input ProblemCreateInput {
  creator: CreatorCreateOneWithoutProblemsInput
  likedBy: CreatorCreateManyWithoutLikesInput
  problemText: String!
}

input ProblemCreateManyWithoutCreatorInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutcreatorInput!]
  create: [ProblemCreateWithoutCreatorInput!]
}

input ProblemCreateManyWithoutLikedByInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutlikedByInput!]
  create: [ProblemCreateWithoutLikedByInput!]
}

input ProblemCreateOrConnectWithoutcreatorInput {
  create: ProblemCreateWithoutCreatorInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateOrConnectWithoutlikedByInput {
  create: ProblemCreateWithoutLikedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateWithoutCreatorInput {
  likedBy: CreatorCreateManyWithoutLikesInput
  problemText: String!
}

input ProblemCreateWithoutLikedByInput {
  creator: CreatorCreateOneWithoutProblemsInput
  problemText: String!
}

input ProblemListRelationFilter {
  every: ProblemWhereInput
  none: ProblemWhereInput
  some: ProblemWhereInput
}

type ProblemMaxAggregate {
  creatorId: Int
  id: Int!
  problemText: String
}

type ProblemMinAggregate {
  creatorId: Int
  id: Int!
  problemText: String
}

input ProblemOrderByInput {
  creatorId: SortOrder
  id: SortOrder
  problemText: SortOrder
}

enum ProblemScalarFieldEnum {
  creatorId
  id
  problemText
}

input ProblemScalarWhereInput {
  AND: [ProblemScalarWhereInput!]
  creatorId: IntNullableFilter
  id: IntFilter
  NOT: [ProblemScalarWhereInput!]
  OR: [ProblemScalarWhereInput!]
  problemText: StringFilter
}

type ProblemSumAggregate {
  creatorId: Int
  id: Int!
}

input ProblemUpdateInput {
  creator: CreatorUpdateOneWithoutProblemsInput
  likedBy: CreatorUpdateManyWithoutLikesInput
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpdateManyMutationInput {
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpdateManyWithoutCreatorInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutcreatorInput!]
  create: [ProblemCreateWithoutCreatorInput!]
  delete: [ProblemWhereUniqueInput!]
  deleteMany: [ProblemScalarWhereInput!]
  disconnect: [ProblemWhereUniqueInput!]
  set: [ProblemWhereUniqueInput!]
  update: [ProblemUpdateWithWhereUniqueWithoutCreatorInput!]
  updateMany: [ProblemUpdateManyWithWhereWithoutCreatorInput!]
  upsert: [ProblemUpsertWithWhereUniqueWithoutCreatorInput!]
}

input ProblemUpdateManyWithoutLikedByInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutlikedByInput!]
  create: [ProblemCreateWithoutLikedByInput!]
  delete: [ProblemWhereUniqueInput!]
  deleteMany: [ProblemScalarWhereInput!]
  disconnect: [ProblemWhereUniqueInput!]
  set: [ProblemWhereUniqueInput!]
  update: [ProblemUpdateWithWhereUniqueWithoutLikedByInput!]
  updateMany: [ProblemUpdateManyWithWhereWithoutLikedByInput!]
  upsert: [ProblemUpsertWithWhereUniqueWithoutLikedByInput!]
}

input ProblemUpdateManyWithWhereWithoutCreatorInput {
  data: ProblemUpdateManyMutationInput!
  where: ProblemScalarWhereInput!
}

input ProblemUpdateManyWithWhereWithoutLikedByInput {
  data: ProblemUpdateManyMutationInput!
  where: ProblemScalarWhereInput!
}

input ProblemUpdateWithoutCreatorInput {
  likedBy: CreatorUpdateManyWithoutLikesInput
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpdateWithoutLikedByInput {
  creator: CreatorUpdateOneWithoutProblemsInput
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpdateWithWhereUniqueWithoutCreatorInput {
  data: ProblemUpdateWithoutCreatorInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpdateWithWhereUniqueWithoutLikedByInput {
  data: ProblemUpdateWithoutLikedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpsertWithWhereUniqueWithoutCreatorInput {
  create: ProblemCreateWithoutCreatorInput!
  update: ProblemUpdateWithoutCreatorInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpsertWithWhereUniqueWithoutLikedByInput {
  create: ProblemCreateWithoutLikedByInput!
  update: ProblemUpdateWithoutLikedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemWhereInput {
  AND: [ProblemWhereInput!]
  creator: CreatorRelationFilter
  creatorId: IntNullableFilter
  id: IntFilter
  likedBy: CreatorListRelationFilter
  NOT: [ProblemWhereInput!]
  OR: [ProblemWhereInput!]
  problemText: StringFilter
}

input ProblemWhereUniqueInput {
  id: Int
}

type Query {
  aggregateClient(cursor: ClientWhereUniqueInput, orderBy: [ClientOrderByInput!], skip: Int, take: Int, where: ClientWhereInput): AggregateClient!
  aggregateCreator(cursor: CreatorWhereUniqueInput, orderBy: [CreatorOrderByInput!], skip: Int, take: Int, where: CreatorWhereInput): AggregateCreator!
  aggregateDirector(cursor: DirectorWhereUniqueInput, orderBy: [DirectorOrderByInput!], skip: Int, take: Int, where: DirectorWhereInput): AggregateDirector!
  aggregateMovie(cursor: MovieWhereUniqueInput, orderBy: [MovieOrderByInput!], skip: Int, take: Int, where: MovieWhereInput): AggregateMovie!
  aggregatePatient(cursor: PatientWhereUniqueInput, orderBy: [PatientOrderByInput!], skip: Int, take: Int, where: PatientWhereInput): AggregatePatient!
  aggregateProblem(cursor: ProblemWhereUniqueInput, orderBy: [ProblemOrderByInput!], skip: Int, take: Int, where: ProblemWhereInput): AggregateProblem!
  allClients: [Client!]!
  allPosts: [Post!]!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  client(where: ClientWhereUniqueInput!): Client
  clients(cursor: ClientWhereUniqueInput, distinct: [ClientScalarFieldEnum!], orderBy: [ClientOrderByInput!], skip: Int, take: Int, where: ClientWhereInput): [Client!]!
  creator(where: CreatorWhereUniqueInput!): Creator
  creators(cursor: CreatorWhereUniqueInput, distinct: [CreatorScalarFieldEnum!], orderBy: [CreatorOrderByInput!], skip: Int, take: Int, where: CreatorWhereInput): [Creator!]!
  customFindClientsWithArgs(cursor: ClientWhereUniqueInput, distinct: [ClientScalarFieldEnum!], orderBy: [ClientOrderByInput!], skip: Int, take: Int, where: ClientWhereInput): [Client!]!
  director(where: DirectorWhereUniqueInput!): Director
  directors(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByInput!], skip: Int, take: Int, where: DirectorWhereInput): [Director!]!
  findFirstClient(cursor: ClientWhereUniqueInput, distinct: [ClientScalarFieldEnum!], orderBy: [ClientOrderByInput!], skip: Int, take: Int, where: ClientWhereInput): Client
  findFirstCreator(cursor: CreatorWhereUniqueInput, distinct: [CreatorScalarFieldEnum!], orderBy: [CreatorOrderByInput!], skip: Int, take: Int, where: CreatorWhereInput): Creator
  findFirstDirector(cursor: DirectorWhereUniqueInput, distinct: [DirectorScalarFieldEnum!], orderBy: [DirectorOrderByInput!], skip: Int, take: Int, where: DirectorWhereInput): Director
  findFirstMovie(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByInput!], skip: Int, take: Int, where: MovieWhereInput): Movie
  findFirstPatient(cursor: PatientWhereUniqueInput, distinct: [PatientScalarFieldEnum!], orderBy: [PatientOrderByInput!], skip: Int, take: Int, where: PatientWhereInput): Patient
  findFirstProblem(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByInput!], skip: Int, take: Int, where: ProblemWhereInput): Problem
  movie(where: MovieWhereUniqueInput!): Movie
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieScalarFieldEnum!], orderBy: [MovieOrderByInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  patient(where: PatientWhereUniqueInput!): Patient
  patients(cursor: PatientWhereUniqueInput, distinct: [PatientScalarFieldEnum!], orderBy: [PatientOrderByInput!], skip: Int, take: Int, where: PatientWhereInput): [Patient!]!
  post(where: PostWhereUniqueInput!): Post
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  problem(where: ProblemWhereUniqueInput!): Problem
  problems(cursor: ProblemWhereUniqueInput, distinct: [ProblemScalarFieldEnum!], orderBy: [ProblemOrderByInput!], skip: Int, take: Int, where: ProblemWhereInput): [Problem!]!
}

enum QueryMode {
  default
  insensitive
}

"""Role enum doc"""
enum Role {
  ADMIN
  USER
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}
