# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AggregateCategory {
  avg: CategoryAvgAggregateOutputType
  count: Int!
  max: CategoryMaxAggregateOutputType
  min: CategoryMinAggregateOutputType
  sum: CategorySumAggregateOutputType
}

type AggregateClient {
  avg: ClientAvgAggregateOutputType
  count: Int!
  max: ClientMaxAggregateOutputType
  min: ClientMinAggregateOutputType
  sum: ClientSumAggregateOutputType
}

type AggregateCreator {
  avg: CreatorAvgAggregateOutputType
  count: Int!
  max: CreatorMaxAggregateOutputType
  min: CreatorMinAggregateOutputType
  sum: CreatorSumAggregateOutputType
}

type AggregateDirector {
  count: Int!
}

type AggregateMovie {
  count: Int!
}

type AggregatePatient {
  count: Int!
}

type AggregateProblem {
  avg: ProblemAvgAggregateOutputType
  count: Int!
  max: ProblemMaxAggregateOutputType
  min: ProblemMinAggregateOutputType
  sum: ProblemSumAggregateOutputType
}

type BatchPayload {
  count: Int!
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Category {
  name: String!
  number: Int!
  slug: String!
}

type CategoryAvgAggregateOutputType {
  number: Float!
}

input CategoryCreateInput {
  name: String!
  number: Int!
  slug: String!
}

enum CategoryDistinctFieldEnum {
  name
  number
  slug
}

type CategoryMaxAggregateOutputType {
  number: Int!
}

type CategoryMinAggregateOutputType {
  number: Int!
}

input CategoryOrderByInput {
  name: SortOrder
  number: SortOrder
  slug: SortOrder
}

type CategorySumAggregateOutputType {
  number: Int!
}

input CategoryUpdateInput {
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  slug: StringFieldUpdateOperationsInput
}

input CategoryUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  slug: StringFieldUpdateOperationsInput
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  name: StringFilter
  NOT: [CategoryWhereInput!]
  number: IntFilter
  OR: [CategoryWhereInput!]
  slug: StringFilter
}

input CategoryWhereUniqueInput {
  slug_number: SlugNumberCompoundUniqueInput
}

"""User model doc"""
type Client {
  accountBalance: Float!
  age: Int!
  amount: Float!
  clientPosts(cursor: PostWhereUniqueInput, distinct: [PostDistinctFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]
  email: String!

  """renamed field doc"""
  firstName: String
  hello: String!

  """User model field doc"""
  id: Int!
  role: Role!
}

type ClientAvgAggregateOutputType {
  age: Float!
  amount: Float!
  balance: Float!
  id: Float!
}

input ClientCreateInput {
  accountBalance: Float!
  age: Int!
  amount: Float!
  clientPosts: PostCreateManyWithoutAuthorInput
  editorPosts: PostCreateManyWithoutEditorInput
  email: String!
  firstName: String
  role: Role!
}

input ClientCreateOneWithoutEditorPostsInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutpostInput
  create: ClientCreateWithoutEditorPostsInput
}

input ClientCreateOneWithoutPostsInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutpostInput
  create: ClientCreateWithoutPostsInput
}

input ClientCreateOrConnectWithoutpostInput {
  create: ClientCreateWithoutPostsInput!
  where: ClientWhereUniqueInput!
}

input ClientCreateWithoutEditorPostsInput {
  accountBalance: Float!
  age: Int!
  amount: Float!
  clientPosts: PostCreateManyWithoutAuthorInput
  email: String!
  firstName: String
  role: Role!
}

input ClientCreateWithoutPostsInput {
  accountBalance: Float!
  age: Int!
  amount: Float!
  editorPosts: PostCreateManyWithoutEditorInput
  email: String!
  firstName: String
  role: Role!
}

enum ClientDistinctFieldEnum {
  accountBalance
  age
  amount
  email
  firstName
  id
  role
}

type ClientMaxAggregateOutputType {
  age: Int!
  amount: Float!
  balance: Float!
  id: Int!
}

type ClientMinAggregateOutputType {
  age: Int!
  amount: Float!
  balance: Float!
  id: Int!
}

input ClientOrderByInput {
  accountBalance: SortOrder
  age: SortOrder
  amount: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  role: SortOrder
}

input ClientRelationFilter {
  is: ClientWhereInput
  isNot: ClientWhereInput
}

type ClientSumAggregateOutputType {
  age: Int!
  amount: Float!
  balance: Float!
  id: Int!
}

input ClientUpdateInput {
  accountBalance: FloatFieldUpdateOperationsInput
  age: IntFieldUpdateOperationsInput
  amount: FloatFieldUpdateOperationsInput
  clientPosts: PostUpdateManyWithoutAuthorInput
  editorPosts: PostUpdateManyWithoutEditorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ClientUpdateManyMutationInput {
  accountBalance: FloatFieldUpdateOperationsInput
  age: IntFieldUpdateOperationsInput
  amount: FloatFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ClientUpdateOneRequiredWithoutPostsInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutpostInput
  create: ClientCreateWithoutPostsInput
  update: ClientUpdateWithoutPostsDataInput
  upsert: ClientUpsertWithoutPostsInput
}

input ClientUpdateOneWithoutEditorPostsInput {
  connect: ClientWhereUniqueInput
  connectOrCreate: ClientCreateOrConnectWithoutpostInput
  create: ClientCreateWithoutEditorPostsInput
  delete: Boolean
  disconnect: Boolean
  update: ClientUpdateWithoutEditorPostsDataInput
  upsert: ClientUpsertWithoutEditorPostsInput
}

input ClientUpdateWithoutEditorPostsDataInput {
  accountBalance: FloatFieldUpdateOperationsInput
  age: IntFieldUpdateOperationsInput
  amount: FloatFieldUpdateOperationsInput
  clientPosts: PostUpdateManyWithoutAuthorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ClientUpdateWithoutPostsDataInput {
  accountBalance: FloatFieldUpdateOperationsInput
  age: IntFieldUpdateOperationsInput
  amount: FloatFieldUpdateOperationsInput
  editorPosts: PostUpdateManyWithoutEditorInput
  email: StringFieldUpdateOperationsInput
  firstName: NullableStringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
}

input ClientUpsertWithoutEditorPostsInput {
  create: ClientCreateWithoutEditorPostsInput!
  update: ClientUpdateWithoutEditorPostsDataInput!
}

input ClientUpsertWithoutPostsInput {
  create: ClientCreateWithoutPostsInput!
  update: ClientUpdateWithoutPostsDataInput!
}

input ClientWhereInput {
  accountBalance: FloatFilter
  age: IntFilter
  amount: FloatFilter
  AND: [ClientWhereInput!]
  clientPosts: PostListRelationFilter
  editorPosts: PostListRelationFilter
  email: StringFilter
  firstName: StringNullableFilter
  id: IntFilter
  NOT: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  role: EnumRoleFilter
}

input ClientWhereUniqueInput {
  email: String
  id: Int
}

type Creator {
  id: Int!
  likes(cursor: ProblemWhereUniqueInput, distinct: [ProblemDistinctFieldEnum!], orderBy: [ProblemOrderByInput!], skip: Int, take: Int, where: ProblemWhereInput): [Problem!]
  name: String!
  problems(cursor: ProblemWhereUniqueInput, distinct: [ProblemDistinctFieldEnum!], orderBy: [ProblemOrderByInput!], skip: Int, take: Int, where: ProblemWhereInput): [Problem!]
}

type CreatorAvgAggregateOutputType {
  id: Float!
}

input CreatorCreateInput {
  likes: ProblemCreateManyWithoutLikedByInput
  name: String!
  problems: ProblemCreateManyWithoutCreatorInput
}

input CreatorCreateManyWithoutLikesInput {
  connect: [CreatorWhereUniqueInput!]
  connectOrCreate: [CreatorCreateOrConnectWithoutProblemInput!]
  create: [CreatorCreateWithoutLikesInput!]
}

input CreatorCreateOneWithoutProblemsInput {
  connect: CreatorWhereUniqueInput
  connectOrCreate: CreatorCreateOrConnectWithoutProblemInput
  create: CreatorCreateWithoutProblemsInput
}

input CreatorCreateOrConnectWithoutProblemInput {
  create: CreatorCreateWithoutLikesInput!
  where: CreatorWhereUniqueInput!
}

input CreatorCreateWithoutLikesInput {
  name: String!
  problems: ProblemCreateManyWithoutCreatorInput
}

input CreatorCreateWithoutProblemsInput {
  likes: ProblemCreateManyWithoutLikedByInput
  name: String!
}

enum CreatorDistinctFieldEnum {
  id
  name
}

input CreatorListRelationFilter {
  every: CreatorWhereInput
  none: CreatorWhereInput
  some: CreatorWhereInput
}

type CreatorMaxAggregateOutputType {
  id: Int!
}

type CreatorMinAggregateOutputType {
  id: Int!
}

input CreatorOrderByInput {
  id: SortOrder
  name: SortOrder
}

input CreatorRelationFilter {
  is: CreatorWhereInput
  isNot: CreatorWhereInput
}

input CreatorScalarWhereInput {
  AND: [CreatorScalarWhereInput!]
  id: IntFilter
  name: StringFilter
  NOT: [CreatorScalarWhereInput!]
  OR: [CreatorScalarWhereInput!]
}

type CreatorSumAggregateOutputType {
  id: Int!
}

input CreatorUpdateInput {
  likes: ProblemUpdateManyWithoutLikedByInput
  name: StringFieldUpdateOperationsInput
  problems: ProblemUpdateManyWithoutCreatorInput
}

input CreatorUpdateManyDataInput {
  name: StringFieldUpdateOperationsInput
}

input CreatorUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input CreatorUpdateManyWithoutLikesInput {
  connect: [CreatorWhereUniqueInput!]
  connectOrCreate: [CreatorCreateOrConnectWithoutProblemInput!]
  create: [CreatorCreateWithoutLikesInput!]
  delete: [CreatorWhereUniqueInput!]
  deleteMany: [CreatorScalarWhereInput!]
  disconnect: [CreatorWhereUniqueInput!]
  set: [CreatorWhereUniqueInput!]
  update: [CreatorUpdateWithWhereUniqueWithoutLikesInput!]
  updateMany: [CreatorUpdateManyWithWhereNestedInput!]
  upsert: [CreatorUpsertWithWhereUniqueWithoutLikesInput!]
}

input CreatorUpdateManyWithWhereNestedInput {
  data: CreatorUpdateManyDataInput!
  where: CreatorScalarWhereInput!
}

input CreatorUpdateOneWithoutProblemsInput {
  connect: CreatorWhereUniqueInput
  connectOrCreate: CreatorCreateOrConnectWithoutProblemInput
  create: CreatorCreateWithoutProblemsInput
  delete: Boolean
  disconnect: Boolean
  update: CreatorUpdateWithoutProblemsDataInput
  upsert: CreatorUpsertWithoutProblemsInput
}

input CreatorUpdateWithoutLikesDataInput {
  name: StringFieldUpdateOperationsInput
  problems: ProblemUpdateManyWithoutCreatorInput
}

input CreatorUpdateWithoutProblemsDataInput {
  likes: ProblemUpdateManyWithoutLikedByInput
  name: StringFieldUpdateOperationsInput
}

input CreatorUpdateWithWhereUniqueWithoutLikesInput {
  data: CreatorUpdateWithoutLikesDataInput!
  where: CreatorWhereUniqueInput!
}

input CreatorUpsertWithoutProblemsInput {
  create: CreatorCreateWithoutProblemsInput!
  update: CreatorUpdateWithoutProblemsDataInput!
}

input CreatorUpsertWithWhereUniqueWithoutLikesInput {
  create: CreatorCreateWithoutLikesInput!
  update: CreatorUpdateWithoutLikesDataInput!
  where: CreatorWhereUniqueInput!
}

input CreatorWhereInput {
  AND: [CreatorWhereInput!]
  id: IntFilter
  likes: ProblemListRelationFilter
  name: StringFilter
  NOT: [CreatorWhereInput!]
  OR: [CreatorWhereInput!]
  problems: ProblemListRelationFilter
}

input CreatorWhereUniqueInput {
  id: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type Director {
  firstName: String!
  lastName: String!
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieDistinctFieldEnum!], orderBy: [MovieOrderByInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]
}

input DirectorCreateInput {
  firstName: String!
  lastName: String!
  movies: MovieCreateManyWithoutDirectorInput
}

input DirectorCreateOneWithoutMoviesInput {
  connect: DirectorWhereUniqueInput
  connectOrCreate: DirectorCreateOrConnectWithoutMovieInput
  create: DirectorCreateWithoutMoviesInput
}

input DirectorCreateOrConnectWithoutMovieInput {
  create: DirectorCreateWithoutMoviesInput!
  where: DirectorWhereUniqueInput!
}

input DirectorCreateWithoutMoviesInput {
  firstName: String!
  lastName: String!
}

enum DirectorDistinctFieldEnum {
  firstName
  lastName
}

input DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput {
  directorFirstName: String!
  directorLastName: String!
  title: String!
}

input DirectorOrderByInput {
  firstName: SortOrder
  lastName: SortOrder
}

input DirectorRelationFilter {
  is: DirectorWhereInput
  isNot: DirectorWhereInput
}

input DirectorUpdateInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  movies: MovieUpdateManyWithoutDirectorInput
}

input DirectorUpdateManyMutationInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input DirectorUpdateOneRequiredWithoutMoviesInput {
  connect: DirectorWhereUniqueInput
  connectOrCreate: DirectorCreateOrConnectWithoutMovieInput
  create: DirectorCreateWithoutMoviesInput
  update: DirectorUpdateWithoutMoviesDataInput
  upsert: DirectorUpsertWithoutMoviesInput
}

input DirectorUpdateWithoutMoviesDataInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input DirectorUpsertWithoutMoviesInput {
  create: DirectorCreateWithoutMoviesInput!
  update: DirectorUpdateWithoutMoviesDataInput!
}

input DirectorWhereInput {
  AND: [DirectorWhereInput!]
  firstName: StringFilter
  lastName: StringFilter
  movies: MovieListRelationFilter
  NOT: [DirectorWhereInput!]
  OR: [DirectorWhereInput!]
}

input DirectorWhereUniqueInput {
  firstName_lastName: FirstNameLastNameCompoundUniqueInput
}

input EnumPostKindNullableFilter {
  equals: PostKind
  in: [PostKind!]
  not: NestedEnumPostKindNullableFilter
  notIn: [PostKind!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input FirstNameLastNameCompoundUniqueInput {
  firstName: String!
  lastName: String!
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  equals: JSON
  not: JSON
}

type Movie {
  director: Director!
  directorFirstName: String!
  directorLastName: String!
  title: String!
}

input MovieCreateInput {
  director: DirectorCreateOneWithoutMoviesInput!
  title: String!
}

input MovieCreateManyWithoutDirectorInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutDirectorInput!]
  create: [MovieCreateWithoutDirectorInput!]
}

input MovieCreateOrConnectWithoutDirectorInput {
  create: MovieCreateWithoutDirectorInput!
  where: MovieWhereUniqueInput!
}

input MovieCreateWithoutDirectorInput {
  title: String!
}

enum MovieDistinctFieldEnum {
  directorFirstName
  directorLastName
  title
}

input MovieListRelationFilter {
  every: MovieWhereInput
  none: MovieWhereInput
  some: MovieWhereInput
}

input MovieOrderByInput {
  directorFirstName: SortOrder
  directorLastName: SortOrder
  title: SortOrder
}

input MovieScalarWhereInput {
  AND: [MovieScalarWhereInput!]
  directorFirstName: StringFilter
  directorLastName: StringFilter
  NOT: [MovieScalarWhereInput!]
  OR: [MovieScalarWhereInput!]
  title: StringFilter
}

input MovieUpdateInput {
  director: DirectorUpdateOneRequiredWithoutMoviesInput
  title: StringFieldUpdateOperationsInput
}

input MovieUpdateManyDataInput {
  title: StringFieldUpdateOperationsInput
}

input MovieUpdateManyMutationInput {
  title: StringFieldUpdateOperationsInput
}

input MovieUpdateManyWithoutDirectorInput {
  connect: [MovieWhereUniqueInput!]
  connectOrCreate: [MovieCreateOrConnectWithoutDirectorInput!]
  create: [MovieCreateWithoutDirectorInput!]
  delete: [MovieWhereUniqueInput!]
  deleteMany: [MovieScalarWhereInput!]
  disconnect: [MovieWhereUniqueInput!]
  set: [MovieWhereUniqueInput!]
  update: [MovieUpdateWithWhereUniqueWithoutDirectorInput!]
  updateMany: [MovieUpdateManyWithWhereNestedInput!]
  upsert: [MovieUpsertWithWhereUniqueWithoutDirectorInput!]
}

input MovieUpdateManyWithWhereNestedInput {
  data: MovieUpdateManyDataInput!
  where: MovieScalarWhereInput!
}

input MovieUpdateWithoutDirectorDataInput {
  title: StringFieldUpdateOperationsInput
}

input MovieUpdateWithWhereUniqueWithoutDirectorInput {
  data: MovieUpdateWithoutDirectorDataInput!
  where: MovieWhereUniqueInput!
}

input MovieUpsertWithWhereUniqueWithoutDirectorInput {
  create: MovieCreateWithoutDirectorInput!
  update: MovieUpdateWithoutDirectorDataInput!
  where: MovieWhereUniqueInput!
}

input MovieWhereInput {
  AND: [MovieWhereInput!]
  director: DirectorRelationFilter
  directorFirstName: StringFilter
  directorLastName: StringFilter
  NOT: [MovieWhereInput!]
  OR: [MovieWhereInput!]
  title: StringFilter
}

input MovieWhereUniqueInput {
  directorFirstName_directorLastName_title: DirectorFirstNameDirectorLastNameTitleCompoundUniqueInput
}

type Mutation {
  createCategory(data: CategoryCreateInput!): Category!
  createClient(data: ClientCreateInput!): Client!
  createCreator(data: CreatorCreateInput!): Creator!
  createDirector(data: DirectorCreateInput!): Director!
  createMovie(data: MovieCreateInput!): Movie!
  createPatient(data: PatientCreateInput!): Patient!
  createPost(data: PostCreateInput!): Post!
  createProblem(data: ProblemCreateInput!): Problem!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteClient(where: ClientWhereUniqueInput!): Client
  deleteCreator(where: CreatorWhereUniqueInput!): Creator
  deleteDirector(where: DirectorWhereUniqueInput!): Director
  deleteManyCategory(where: CategoryWhereInput): BatchPayload!
  deleteManyClient(where: ClientWhereInput): BatchPayload!
  deleteManyCreator(where: CreatorWhereInput): BatchPayload!
  deleteManyDirector(where: DirectorWhereInput): BatchPayload!
  deleteManyMovie(where: MovieWhereInput): BatchPayload!
  deleteManyPatient(where: PatientWhereInput): BatchPayload!
  deleteManyProblem(where: ProblemWhereInput): BatchPayload!
  deleteMovie(where: MovieWhereUniqueInput!): Movie
  deletePatient(where: PatientWhereUniqueInput!): Patient
  deleteProblem(where: ProblemWhereUniqueInput!): Problem
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateCreator(data: CreatorUpdateInput!, where: CreatorWhereUniqueInput!): Creator
  updateDirector(data: DirectorUpdateInput!, where: DirectorWhereUniqueInput!): Director
  updateManyCategory(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): BatchPayload!
  updateManyClient(data: ClientUpdateManyMutationInput!, where: ClientWhereInput): BatchPayload!
  updateManyCreator(data: CreatorUpdateManyMutationInput!, where: CreatorWhereInput): BatchPayload!
  updateManyDirector(data: DirectorUpdateManyMutationInput!, where: DirectorWhereInput): BatchPayload!
  updateManyMovie(data: MovieUpdateManyMutationInput!, where: MovieWhereInput): BatchPayload!
  updateManyPatient(data: PatientUpdateManyMutationInput!, where: PatientWhereInput): BatchPayload!
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  updateManyProblem(data: ProblemUpdateManyMutationInput!, where: ProblemWhereInput): BatchPayload!
  updateMovie(data: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie
  updatePatient(data: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient
  updateProblem(data: ProblemUpdateInput!, where: ProblemWhereUniqueInput!): Problem
  upsertCategory(create: CategoryCreateInput!, update: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  upsertClient(create: ClientCreateInput!, update: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client!
  upsertCreator(create: CreatorCreateInput!, update: CreatorUpdateInput!, where: CreatorWhereUniqueInput!): Creator!
  upsertDirector(create: DirectorCreateInput!, update: DirectorUpdateInput!, where: DirectorWhereUniqueInput!): Director!
  upsertMovie(create: MovieCreateInput!, update: MovieUpdateInput!, where: MovieWhereUniqueInput!): Movie!
  upsertPatient(create: PatientCreateInput!, update: PatientUpdateInput!, where: PatientWhereUniqueInput!): Patient!
  upsertProblem(create: ProblemCreateInput!, update: ProblemUpdateInput!, where: ProblemWhereUniqueInput!): Problem!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumPostKindNullableFilter {
  equals: PostKind
  in: [PostKind!]
  not: NestedEnumPostKindNullableFilter
  notIn: [PostKind!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableEnumPostKindFieldUpdateOperationsInput {
  set: PostKind
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Patient {
  email: String!
  firstName: String!
  lastName: String!
}

input PatientCreateInput {
  email: String!
  firstName: String!
  lastName: String!
}

enum PatientDistinctFieldEnum {
  email
  firstName
  lastName
}

input PatientOrderByInput {
  email: SortOrder
  firstName: SortOrder
  lastName: SortOrder
}

input PatientUpdateInput {
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input PatientUpdateManyMutationInput {
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input PatientWhereInput {
  AND: [PatientWhereInput!]
  email: StringFilter
  firstName: StringFilter
  lastName: StringFilter
  NOT: [PatientWhereInput!]
  OR: [PatientWhereInput!]
}

input PatientWhereUniqueInput {
  firstName_lastName: FirstNameLastNameCompoundUniqueInput
}

type Post {
  author: Client!
  authorId: Int!
  content: String
  createdAt: DateTime!
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  title: String!
  updatedAt: DateTime!
  uuid: String!
}

input PostCreateInput {
  author: ClientCreateOneWithoutPostsInput!
  content: String
  createdAt: DateTime
  editor: ClientCreateOneWithoutEditorPostsInput
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime
  uuid: String
}

input PostCreateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutUserInput!]
  create: [PostCreateWithoutAuthorInput!]
}

input PostCreateManyWithoutEditorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutUserInput!]
  create: [PostCreateWithoutEditorInput!]
}

input PostCreateOrConnectWithoutUserInput {
  create: PostCreateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutAuthorInput {
  content: String
  createdAt: DateTime
  editor: ClientCreateOneWithoutEditorPostsInput
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime
  uuid: String
}

input PostCreateWithoutEditorInput {
  author: ClientCreateOneWithoutPostsInput!
  content: String
  createdAt: DateTime
  kind: PostKind
  metadata: JSON!
  published: Boolean!
  subtitle: String!
  title: String!
  updatedAt: DateTime
  uuid: String
}

enum PostDistinctFieldEnum {
  authorId
  content
  createdAt
  editorId
  kind
  metadata
  published
  subtitle
  title
  updatedAt
  uuid
}

enum PostKind {
  ADVERT
  BLOG
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

input PostOrderByInput {
  authorId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  editorId: SortOrder
  kind: SortOrder
  metadata: SortOrder
  published: SortOrder
  subtitle: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uuid: SortOrder
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  authorId: IntFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  editorId: IntNullableFilter
  kind: EnumPostKindNullableFilter
  metadata: JsonFilter
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  published: BoolFilter
  subtitle: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  uuid: StringFilter
}

input PostUpdateManyDataInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  kind: NullableEnumPostKindFieldUpdateOperationsInput
  metadata: JSON
  published: BoolFieldUpdateOperationsInput
  subtitle: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  uuid: StringFieldUpdateOperationsInput
}

input PostUpdateManyMutationInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  kind: NullableEnumPostKindFieldUpdateOperationsInput
  metadata: JSON
  published: BoolFieldUpdateOperationsInput
  subtitle: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  uuid: StringFieldUpdateOperationsInput
}

input PostUpdateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutUserInput!]
  create: [PostCreateWithoutAuthorInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateManyWithoutEditorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutUserInput!]
  create: [PostCreateWithoutEditorInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutEditorInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutEditorInput!]
}

input PostUpdateManyWithWhereNestedInput {
  data: PostUpdateManyDataInput!
  where: PostScalarWhereInput!
}

input PostUpdateWithoutAuthorDataInput {
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  editor: ClientUpdateOneWithoutEditorPostsInput
  kind: NullableEnumPostKindFieldUpdateOperationsInput
  metadata: JSON
  published: BoolFieldUpdateOperationsInput
  subtitle: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  uuid: StringFieldUpdateOperationsInput
}

input PostUpdateWithoutEditorDataInput {
  author: ClientUpdateOneRequiredWithoutPostsInput
  content: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  kind: NullableEnumPostKindFieldUpdateOperationsInput
  metadata: JSON
  published: BoolFieldUpdateOperationsInput
  subtitle: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  uuid: StringFieldUpdateOperationsInput
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  data: PostUpdateWithoutAuthorDataInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithWhereUniqueWithoutEditorInput {
  data: PostUpdateWithoutEditorDataInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  update: PostUpdateWithoutAuthorDataInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithWhereUniqueWithoutEditorInput {
  create: PostCreateWithoutEditorInput!
  update: PostUpdateWithoutEditorDataInput!
  where: PostWhereUniqueInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  author: ClientRelationFilter
  authorId: IntFilter
  content: StringNullableFilter
  createdAt: DateTimeFilter
  editor: ClientRelationFilter
  editorId: IntNullableFilter
  kind: EnumPostKindNullableFilter
  metadata: JsonFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  published: BoolFilter
  subtitle: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  uuid: StringFilter
}

input PostWhereUniqueInput {
  uuid: String
}

type Problem {
  creator: Creator
  creatorId: Int
  id: Int!
  likedBy(cursor: CreatorWhereUniqueInput, distinct: [CreatorDistinctFieldEnum!], orderBy: [CreatorOrderByInput!], skip: Int, take: Int, where: CreatorWhereInput): [Creator!]
  problemText: String!
}

type ProblemAvgAggregateOutputType {
  creatorId: Float
  id: Float!
}

input ProblemCreateInput {
  creator: CreatorCreateOneWithoutProblemsInput
  likedBy: CreatorCreateManyWithoutLikesInput
  problemText: String!
}

input ProblemCreateManyWithoutCreatorInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutCreatorInput!]
  create: [ProblemCreateWithoutCreatorInput!]
}

input ProblemCreateManyWithoutLikedByInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutCreatorInput!]
  create: [ProblemCreateWithoutLikedByInput!]
}

input ProblemCreateOrConnectWithoutCreatorInput {
  create: ProblemCreateWithoutLikedByInput!
  where: ProblemWhereUniqueInput!
}

input ProblemCreateWithoutCreatorInput {
  likedBy: CreatorCreateManyWithoutLikesInput
  problemText: String!
}

input ProblemCreateWithoutLikedByInput {
  creator: CreatorCreateOneWithoutProblemsInput
  problemText: String!
}

enum ProblemDistinctFieldEnum {
  creatorId
  id
  problemText
}

input ProblemListRelationFilter {
  every: ProblemWhereInput
  none: ProblemWhereInput
  some: ProblemWhereInput
}

type ProblemMaxAggregateOutputType {
  creatorId: Int
  id: Int!
}

type ProblemMinAggregateOutputType {
  creatorId: Int
  id: Int!
}

input ProblemOrderByInput {
  creatorId: SortOrder
  id: SortOrder
  problemText: SortOrder
}

input ProblemScalarWhereInput {
  AND: [ProblemScalarWhereInput!]
  creatorId: IntNullableFilter
  id: IntFilter
  NOT: [ProblemScalarWhereInput!]
  OR: [ProblemScalarWhereInput!]
  problemText: StringFilter
}

type ProblemSumAggregateOutputType {
  creatorId: Int
  id: Int!
}

input ProblemUpdateInput {
  creator: CreatorUpdateOneWithoutProblemsInput
  likedBy: CreatorUpdateManyWithoutLikesInput
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpdateManyDataInput {
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpdateManyMutationInput {
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpdateManyWithoutCreatorInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutCreatorInput!]
  create: [ProblemCreateWithoutCreatorInput!]
  delete: [ProblemWhereUniqueInput!]
  deleteMany: [ProblemScalarWhereInput!]
  disconnect: [ProblemWhereUniqueInput!]
  set: [ProblemWhereUniqueInput!]
  update: [ProblemUpdateWithWhereUniqueWithoutCreatorInput!]
  updateMany: [ProblemUpdateManyWithWhereNestedInput!]
  upsert: [ProblemUpsertWithWhereUniqueWithoutCreatorInput!]
}

input ProblemUpdateManyWithoutLikedByInput {
  connect: [ProblemWhereUniqueInput!]
  connectOrCreate: [ProblemCreateOrConnectWithoutCreatorInput!]
  create: [ProblemCreateWithoutLikedByInput!]
  delete: [ProblemWhereUniqueInput!]
  deleteMany: [ProblemScalarWhereInput!]
  disconnect: [ProblemWhereUniqueInput!]
  set: [ProblemWhereUniqueInput!]
  update: [ProblemUpdateWithWhereUniqueWithoutLikedByInput!]
  updateMany: [ProblemUpdateManyWithWhereNestedInput!]
  upsert: [ProblemUpsertWithWhereUniqueWithoutLikedByInput!]
}

input ProblemUpdateManyWithWhereNestedInput {
  data: ProblemUpdateManyDataInput!
  where: ProblemScalarWhereInput!
}

input ProblemUpdateWithoutCreatorDataInput {
  likedBy: CreatorUpdateManyWithoutLikesInput
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpdateWithoutLikedByDataInput {
  creator: CreatorUpdateOneWithoutProblemsInput
  problemText: StringFieldUpdateOperationsInput
}

input ProblemUpdateWithWhereUniqueWithoutCreatorInput {
  data: ProblemUpdateWithoutCreatorDataInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpdateWithWhereUniqueWithoutLikedByInput {
  data: ProblemUpdateWithoutLikedByDataInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpsertWithWhereUniqueWithoutCreatorInput {
  create: ProblemCreateWithoutCreatorInput!
  update: ProblemUpdateWithoutCreatorDataInput!
  where: ProblemWhereUniqueInput!
}

input ProblemUpsertWithWhereUniqueWithoutLikedByInput {
  create: ProblemCreateWithoutLikedByInput!
  update: ProblemUpdateWithoutLikedByDataInput!
  where: ProblemWhereUniqueInput!
}

input ProblemWhereInput {
  AND: [ProblemWhereInput!]
  creator: CreatorRelationFilter
  creatorId: IntNullableFilter
  id: IntFilter
  likedBy: CreatorListRelationFilter
  NOT: [ProblemWhereInput!]
  OR: [ProblemWhereInput!]
  problemText: StringFilter
}

input ProblemWhereUniqueInput {
  id: Int
}

type Query {
  aggregateCategory(cursor: CategoryWhereUniqueInput, distinct: [CategoryDistinctFieldEnum!], orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): AggregateCategory!
  aggregateClient(cursor: ClientWhereUniqueInput, distinct: [ClientDistinctFieldEnum!], orderBy: [ClientOrderByInput!], skip: Int, take: Int, where: ClientWhereInput): AggregateClient!
  aggregateCreator(cursor: CreatorWhereUniqueInput, distinct: [CreatorDistinctFieldEnum!], orderBy: [CreatorOrderByInput!], skip: Int, take: Int, where: CreatorWhereInput): AggregateCreator!
  aggregateDirector(cursor: DirectorWhereUniqueInput, distinct: [DirectorDistinctFieldEnum!], orderBy: [DirectorOrderByInput!], skip: Int, take: Int, where: DirectorWhereInput): AggregateDirector!
  aggregateMovie(cursor: MovieWhereUniqueInput, distinct: [MovieDistinctFieldEnum!], orderBy: [MovieOrderByInput!], skip: Int, take: Int, where: MovieWhereInput): AggregateMovie!
  aggregatePatient(cursor: PatientWhereUniqueInput, distinct: [PatientDistinctFieldEnum!], orderBy: [PatientOrderByInput!], skip: Int, take: Int, where: PatientWhereInput): AggregatePatient!
  aggregateProblem(cursor: ProblemWhereUniqueInput, distinct: [ProblemDistinctFieldEnum!], orderBy: [ProblemOrderByInput!], skip: Int, take: Int, where: ProblemWhereInput): AggregateProblem!
  allClients: [Client!]!
  allPosts: [Post!]!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryDistinctFieldEnum!], orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  category(where: CategoryWhereUniqueInput!): Category
  client(where: ClientWhereUniqueInput!): Client
  clients(cursor: ClientWhereUniqueInput, distinct: [ClientDistinctFieldEnum!], orderBy: [ClientOrderByInput!], skip: Int, take: Int, where: ClientWhereInput): [Client!]!
  creator(where: CreatorWhereUniqueInput!): Creator
  creators(cursor: CreatorWhereUniqueInput, distinct: [CreatorDistinctFieldEnum!], orderBy: [CreatorOrderByInput!], skip: Int, take: Int, where: CreatorWhereInput): [Creator!]!
  customFindClientsWithArgs(cursor: ClientWhereUniqueInput, distinct: [ClientDistinctFieldEnum!], orderBy: [ClientOrderByInput!], skip: Int, take: Int, where: ClientWhereInput): [Client!]!
  director(where: DirectorWhereUniqueInput!): Director
  directors(cursor: DirectorWhereUniqueInput, distinct: [DirectorDistinctFieldEnum!], orderBy: [DirectorOrderByInput!], skip: Int, take: Int, where: DirectorWhereInput): [Director!]!
  findFirstCategory(cursor: CategoryWhereUniqueInput, distinct: [CategoryDistinctFieldEnum!], orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstClient(cursor: ClientWhereUniqueInput, distinct: [ClientDistinctFieldEnum!], orderBy: [ClientOrderByInput!], skip: Int, take: Int, where: ClientWhereInput): Client
  findFirstCreator(cursor: CreatorWhereUniqueInput, distinct: [CreatorDistinctFieldEnum!], orderBy: [CreatorOrderByInput!], skip: Int, take: Int, where: CreatorWhereInput): Creator
  findFirstDirector(cursor: DirectorWhereUniqueInput, distinct: [DirectorDistinctFieldEnum!], orderBy: [DirectorOrderByInput!], skip: Int, take: Int, where: DirectorWhereInput): Director
  findFirstMovie(cursor: MovieWhereUniqueInput, distinct: [MovieDistinctFieldEnum!], orderBy: [MovieOrderByInput!], skip: Int, take: Int, where: MovieWhereInput): Movie
  findFirstPatient(cursor: PatientWhereUniqueInput, distinct: [PatientDistinctFieldEnum!], orderBy: [PatientOrderByInput!], skip: Int, take: Int, where: PatientWhereInput): Patient
  findFirstProblem(cursor: ProblemWhereUniqueInput, distinct: [ProblemDistinctFieldEnum!], orderBy: [ProblemOrderByInput!], skip: Int, take: Int, where: ProblemWhereInput): Problem
  movie(where: MovieWhereUniqueInput!): Movie
  movies(cursor: MovieWhereUniqueInput, distinct: [MovieDistinctFieldEnum!], orderBy: [MovieOrderByInput!], skip: Int, take: Int, where: MovieWhereInput): [Movie!]!
  patient(where: PatientWhereUniqueInput!): Patient
  patients(cursor: PatientWhereUniqueInput, distinct: [PatientDistinctFieldEnum!], orderBy: [PatientOrderByInput!], skip: Int, take: Int, where: PatientWhereInput): [Patient!]!
  post(where: PostWhereUniqueInput!): Post
  posts(cursor: PostWhereUniqueInput, distinct: [PostDistinctFieldEnum!], orderBy: [PostOrderByInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  problem(where: ProblemWhereUniqueInput!): Problem
  problems(cursor: ProblemWhereUniqueInput, distinct: [ProblemDistinctFieldEnum!], orderBy: [ProblemOrderByInput!], skip: Int, take: Int, where: ProblemWhereInput): [Problem!]!
}

enum QueryMode {
  default
  insensitive
}

"""Role enum doc"""
enum Role {
  ADMIN
  USER
}

input SlugNumberCompoundUniqueInput {
  number: Int!
  slug: String!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}
